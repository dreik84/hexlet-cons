--- Введение ---

Стримы Java - это абстракция, которая позволяет обрабатывать последовательности данных, например, коллекции в декларативном стиле. 

--- Декларативное программирование ---

Декларативное программирование - это парадигма программирования, которая фокусируется на том, что компьютер должен сделать, а не том как это сделать.

До сих пор мы, в основном, программировали в императивном стиле, в котором фокус идет на том как выполняется код. Классический пример это циклы, где мы указываем последовательность шагов, которые нужно выполнить, чтобы добиться нужного результата. Каждый шаг это ответ на вопрос как.

var fruits = new ArrayList<>(List.of("Orange", "Apple", "Banana", "Grapes", "Cherry"));

fruits.sort((v1, v2) -> v1.compareTo(v2));
System.out.println(fruits); // Вывод: [Apple, Banana, Cherry, Grapes, Orange]

Примерно так работают стримы, они прячут перебор коллекций от нас так, чтобы мы могли фокусироваться на решаемой задаче.

-- Стримы --

Стримы представляют собой последовательность элементов с набором методов позволяющих преобразовывать эти элементы и выполнять над ними разнообразные вычисления. Исходная коллекция, в большинстве случаев, не меняется.

var names = users.stream() // Создаем стрим
            .filter(user -> user.getAge() > 18) // Фильтрация пользователей старше 18 лет
            .map(User::getName) // Преобразование User в String (имя пользователя)
            .sorted() // Сортировка имен в алфавитном порядке
            .toList(); // Сбор результата в список

Основные элементы работы со стримами:

- Коллекция сама по себе не является стримом, сначала нужно выполнить преобразование. В случае списков для этого нужно вызвать метод stream().
- Почти всегда в конце работы стрима нужно преобразовать его в список toList().

Так как эти методы возвращают коллекцию, то мы можем объединять их в цепочки, создавая более сложные варианты обработки данных. Благодаря разделению и возможности комбинации, стримы позволяют решать большинство задач преобразования коллекций без необходимости возвращаться к циклам.

Стримы работают и для массивов. Чтобы сделать стрим из массива, нужно вызвать метод Arrays.stream().

String[] chars = {"h", "e", "x", "l", "e", "t"};
var stream = Arrays.stream(chars);

--  Отображение (map) --

Базовая операция в стримах это map() (отображение). Она берет исходный список и формирует на его основе другой, преобразуя каждый элемент по указанным правилам. 

var roundedNumbers = numbers.stream()
                            .map(number -> Math.round(number))
                            // или проще через передачу ссылки
                            // .map(Math::round)
                            .toList();

Метод map() принимает как параметр лямбда-функцию, которая должна вернуть значение, вычисленное на базе переданного значения из исходной коллекции. Результатом может быть все что угодно. При этом отображение никогда не меняет размер коллекции, на выходе будет ровно то же, что было на входе.

--- Фильтрация ---

Операция filter() (фильтрация) позволяет отсеивать элементы из потока данных на основе заданных критериев. 

В отличие от операции отображения, фильтрация не выполняет преобразования элемента, она лишь вычисляет необходимость добавить это значение в результирующую коллекцию. Лямбда-функция в этом случае называется предикатом, так как ее задача вернуть булево значение. Если значение нужно добавить в новую коллекцию, тогда возвращается true, иначе false. Стримы позволяют выразить эту операцию в одну строчку:

// Фильтрация для выбора только четных чисел
var evenNumbers = numbers.stream()
                         .filter(number -> number % 2 == 0)
                         .toList();

Фильтрация всегда возвращает неизмененные элементы, но их количество может быть любым, включая все элементы исходной коллекции если они все удовлетворяют предикату и не включая никакие элементы в обратной ситуации. Тогда возвращается пустая коллекция.

--- Свертка (reduce) ---

Операция reduce() (свертка) - это терминальная операция, которая обрабатывает элементы стрима и возвращает одно значение. 

Свертка отличается от остальных операций преобразования списка тремя аспектами:

- У свертки есть начальное значение. В случае суммы это ноль, в случае умножения — единица и так далее.
- Следующее значение в свертке базируется на результате, который был получен на предыдущей итерации.
- Свертка — терминальная операция, то есть она возвращает какое-то значение, которому не нужно выполнять преобразование в список с помощью toList()

var sum = numbers.stream()
                 .reduce(0, (subtotal, element) -> subtotal + element);
                 // или используя Integer.sum(subtotal, element)
                 // .reduce(0, Integer::sum);

reduce() принимает на вход два параметра, первый это начальное значение, второй лямбда выполняющая операцию свертки. В эту лямбду приходит два параметра: результат предыдущего вычисления и текущий элемент. Накапливаемый результат в процессе вычисления принято называть аккумулятором, так как он аккумулирует значение. Новое значение аккумулятора, всегда равно тому, что было возвращено из предыдущего вызова лямбды.

-- Отличающиеся типы --

В примерах выше, тип данных в коллекции и тип аккумулятора совпадали. Так бывает не всегда, в любой нетривиальной ситуации типы скорее всего будут отличаться.

var products = List.of("Laptop: 800", "Headphones: 50", "Smartphone: 500", "Mouse: 20");

var totalPrice = products.stream()
                         .reduce(0,
                                 (sum, product) -> {
                                     var parts = product.split(": ");
                                     var price = Integer.parseInt(parts[1].trim());
                                     return sum + price;
                                 }); 
Несмотря на то, что код выглядит правильно, он не компилируется с ошибкой.

Если не вдаваться в подробности, то связано это с тем, что типы выводятся таким образом:

ArrayList<T>
(T, T) -> T

Выйти из этой ситуации можно с помощью комбайнера, третьего параметра в reduce(), который обычно используется для параллельного запуска вычисления. В таком случае reduce() работает так:

- Коллекция разбивается на части
- Каждая часть обрабатывается в своем потоке выполнения, в результате которого образуется несколько аккумуляторов
- С помощью функции комбайнера эти аккумуляторы собираются в один аккумулятор. В случае числовых аккумуляторов, обычно комбайнер это функция их суммирования, в случае списков это слияние списков и тому подобное.

Комбайнер помогает компилятору увидеть тип аккумулятора, поэтому код с комбайнером компилируется.

var products = List.of("Laptop: 800", "Headphones: 50", "Smartphone: 500", "Mouse: 20");

var totalPrice = products.stream()
                         .reduce(0,
                                 (sum, product) -> {
                                     var parts = product.split(": ");
                                     var price = Integer.parseInt(parts[1].trim());
                                     return sum + price;
                                 },
                                 Integer::sum);

При этом параллельного выполнения происходить не будет, так как для этого нужно работать не с обычным стримом stream(), а с параллельным parallelStream(). Это выглядит немного странно, но так устроен reduce().

--- Цепочка вызовов ---

Вспомним код из предыдущего урока, в котором мы вычисляли стоимость товаров в списке.
Если сформулировать словами то, что здесь происходит то мы получим такой алгоритм:

- Извлекаем цены из списка товаров.
- Находим общую стоимость.

Если присмотреться, то можно увидеть, что первая операция очень похожа на отображение. То есть, мы здесь имеем дело не с одной сверткой, а с двумя последовательными операциями. Перепишем код таким образом.

var totalPrice = products.stream()
                         .map((product) -> {
                             var parts = product.split(": ");
                             var price = Integer.parseInt(parts[1].trim());
                             return price;
                         })
                         .reduce(0, Integer::sum);

Так как map() возвращает Stream, то мы можем сразу продолжить нашу цепочку вызовов.

В этом разделении кроется одна из ключевых особенностей использования стримов, которая помогает делать код проще и понятнее. Разделение на независимые этапы позволяет разбить сложную операцию таким образом, что на каждом этапе понадобится думать только о небольшой операции, которую легко проанализировать. Такого же эффекта нельзя добиться с циклами, так как циклы не комбинируются, каждый цикл живет своей собственной жизнью в отличие от стрима.

Предположим, что у нас есть список сотрудников какой-то компании и мы хотим посчитать количество денег, которые тратятся на зарплаты в одном из подразделений. Эта задача распадается на три этапа.

- Фильтрация. Оставляем сотрудников только для нужного подразделения.
- Отображение. Извлекаем зарплату.
- Свертка. Считаем общую сумму.

var totalItSalary = employees
    .stream()
    .filter(e -> "IT".equals(e.getDepartment()))
    .map(Employee::getSalary)
    .reduce(0, Integer::sum);

-- Ленивое выполнение --

Глядя на последний пример, может возникнуть вопрос, а не слишком ли расточительно обходить столько раз список, во время фильтрации, во время отображения и при свертке? В действительности список обходится ровно один раз. Происходит это потому, что стримы в Java ленивые. То есть, несмотря на вызов методов filter() и map() их реальный вызов не начинается до тех пор, пока эти данные не понадобятся. При этом внутри все реализовано таким образом, что выполняется один проход, во время которого данные пропускаются через всю цепочку функций.

В том числе по этой причине мы вызывали toList(), когда рассматривали map() и filter(). Этот метод запускает процесс вычисления. reduce() тоже запускает вычисление, так как это терминальная операция, на которой stream обрывается.

--- Стандартные методы свертки (Collectors) ---

Обработка коллекций через стримы в основном заканчивается двумя вариантами:

- Из стрима формируется список через toList()
- Стрим сворачивается в какое-то значение через reduce()

Второй случай распадается на различные варианты свертки, некоторые из которых встречаются очень часто. Чтобы не делать каждый раз одно и тоже, эти варианты сверток были реализованы в утилитарном классе Collectors в виде статических методов.

Общий принцип работы этих методов такой. В конце цепочки вызывается метод collect(), куда передается конкретный коллектор. Пример подсчета количества элементов стрима:

import java.util.stream.Collectors;

var numbers = List.of(1, 2, 3, 4, 5);
var count = numbers.stream().collect(Collectors.counting());
System.out.println(count); // => 5

-- Агрегирующие функции --

Классическая свертка это разнообразные функции агрегации данных, такие как поиск суммы, минимального, максимального и среднего.

var numbers = List.of(1, 2, 3, 4, 5);
var sum = numbers.stream()
               .collect(Collectors.summingInt(Integer::intValue));
System.out.println(sum); // => 15

-- Конкатенация --

Результат стрима можно преобразовать в строку с помощью Collectors.joining().

var list = List.of("Apple", "Banana", "Cherry");
var result = list.stream()
                 .collect(Collectors.joining(", "));
System.out.println(result); // => Apple, Banana, Cherry

-- Группировка --

Самый интересный вариант использования Collectors это группировка значений коллекции по каким-то признакам. Если предположить что у нас есть список сотрудников, то мы можем сгруппировать его по подразделению в котором они работают. На выходе получится Map.

// Map<String, List<Employee>>
var employeesByDepartment = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

-- Партицирование --

Партицирование, это вариант свертки, в котором список значений делится на две группы по заданному условию. Выполняется с помощью метода Collectors.partitioningBy().

// Map<Boolean, List<Integer>>
var groups = numbers.stream()
                    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8, 10]}

--- Выравнивание данных (Flat Map) ---

В разработке иногда встречается задача "выпрямления" вложенных списков, то есть создания одного плоского списка из списка списков или списка массивов. В стримах за это отвечает метод flatMap(), который работает как показано в коде ниже.

var listOfLists = List.of(
    List.of(1, 2, 3),
    List.of(4, 5, 6),
    List.of(7, 8, 9)
);

// Stream<List<Integer>> to Stream<Integer>
var flattenedList = listOfLists.stream()
    .flatMap(List::stream)
    .toList();

System.out.println(flattenedList); // Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

flatMap() работает как отображение map, которое применяет к каждому элементу стрима переданную лямбду. Эта лямбда преобразует каждый элемент, в нашем случае список чисел, в стрим. Когда все элементы преобразованы в стримы, выполняется вторая часть flatMap, стримы объединяются в один.

--- Поиск элементов (find) ---

Метод findFirst() используется в связке с filter() для поиска первого элемента, соответствующего условию фильтрации.

var fruits = List.of("Apple", "Banana", "Apricot", "Orange", "Avocado");
var maybeFruit = fruits.stream()
                  .filter(s -> s.startsWith("A"))
                  .findFirst();

System.out.println(maybeFruit); // Optional[Apple]

Так как findFirst() ищет ровно один элемент, то его результатом является одно значение, а не стрим. Но в отличие от свертки, где результат это то, что находится в аккумуляторе, в случае findFirst() в качестве результата возвращается особый тип данных Optional. 

По логике кажется, что возвратом должно быть либо конкретное значение если оно найдено, либо null. Но в таком случае возникает необходимость постоянной проверки на наличие значения if (value != null). Главная проблема в том, что если забыть сделать ее проверку, компилятор ругаться не будет, null является валидным значением для любых не примитивных типов. И такое постоянно происходит в тех местах, где возвратом может быть null. Исключение NullPointerException одно из самых распространенных в работающих программах на Java.

Чтобы этого не происходило в язык ввели тип Optional. Это тип обертка, который хранит реальное значение внутри себя предоставляя к нему доступ через различные методы.

Optional создается следующим образом:

Optional.empty(): создает Optional в случае если значение отсутствует.
Optional.of(value): создает Optional с value внутри.
Optional.ofNullable(value): работает как empty() если значение null, иначе как of().

-- Основные методы Optional --

get(): Возвращает значение если оно есть иначе выбрасывается исключение NoSuchElementException.
isPresent(): Возвращает true если значение представлено.
orElse(defaultValue): Возвращает значение если оно есть иначе возвращается defaultValue.
orElseThrow(exceptionSupplier): Возвращает значение, если оно существует, иначе выбрасывает исключение, созданное внутри exceptionSupplier.

--- Как эффективно работать со стримами ---

Как и любой мощный инструмент, стримы с одной стороны делают код короче и удобнее, но с другой, неправильное их использование может значительно все усложнить. Особенно учитывая то, что с помощью стримов одна и та же задача может быть решена совершенно разными способами.

-- Приоритет читаемости и ясности --

Сложные стримы разбивайте на более мелкие и понятные шаги.

-- Избегайте побочных эффектов --

Операции со стримами должны избегать изменения исходных данных.

-- Читаемость важнее производительности --

Используйте стримы для улучшения читаемости кода.

-- Используйте ссылки на методы --

Для упрощения кода используйте ссылки на методы.

-- Ограничьте область применения потоков --

Используйте стримы для сложных операций с коллекциями.

-- Будьте осторожны с терминальными операциями --

После терминальной операции стрим нельзя использовать повторно. 

-- Используйте невмешательные операции --

Не изменяйте источник стрима во время его обработки. Пример: Изменение списка во время обработки стрима может привести к непредсказуемым результатам