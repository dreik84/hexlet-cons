--- Введение ---

Этот курс представляет собой захватывающее путешествие в мир функционального программирования на Java. Вы углубитесь в изучение таких ключевых понятий, как лямбда-функции, функции высшего порядка, композиция функций, функциональные интерфейсы и рассмотрите, как функции могут быть использованы как объекты первого рода в Java. Эти концепции необходимы для разработки эффективного, модульного и легко поддерживаемого кода.

--- Лямбда-функции ---

До сих пор в Java мы встречались только с методами, хотя и слышали термин «функция». В отличие от методов, функции существуют сами по себе без привязки к классу. Технически Java не позволяет создавать подобные функции, поэтому почти всегда, когда нужна обычная функция, в Java создается статический метод.

Статические методы вполне заменяют обычные функции, хотя и делают код более многословным. Но встречаются и другие ситуации, где функции удобны и речь здесь идет про лямбда-функции или, как их еще называют, анонимные функции.

-- forEach() в Map --

Рассмотрим на примере Map. Для того чтобы обойти пары ключ-значения, мы скорее всего воспользуемся методом entrySet(), который возвращает специальный объект, содержащий и ключ и значение.

Но эту же задачу можно решить проще, если воспользоваться методом forEach(), который работает с лямбда-функциями.

codes.forEach((key, value) -> {
    System.out.println(key);
    System.out.println(value);
});

В этом примере мы используем метод forEach(), параметром которого является лямбда-функция. Эта лямбда-функция принимает на вход два параметра: ключ и значение. В ее теле выполняется тот код, который мы напишем.

Лямбда-функция записывается так: () -> {}. То, что в скобках – это параметры. То, что в фигурных скобках – это тело функции. Знак -> отделяет параметры от тела. Особенностью лямбда-функций является то, что параметры указываются без типов данных.

-- forEach() в списках --

Похожая реализация forEach() есть и в списках. Здесь лямбда-функция принимает на вход один параметр.

temperatures.forEach(value -> System.out.println(value));

В этом примере произошло два упрощения:

- Убраны фигурные скобки у тела функции — такое допустимо, если внутри тела выполняется одна инструкция
- Убраны скобки вокруг параметра — это допустимо, если параметр всего один

-- Упрощенный синтаксис лямбда-функций --

Лямбда-функции могут не только выполнять какое-то действие, но и возвращать значение. Рассмотрим на примере метода replaceAll() в списках. Метод заменяет каждый элемент списка на результат, который вернет лямбда-функция для текущего элемента

temperatures.replaceAll(value -> {
    return value + 273;
});

В Java существует альтернативный вариант записи лямбда-функций

temperatures.replaceAll(value -> value + 273);

В этом примере мы опустили фигурные скобки у тела функции и ключевое слово return. Так можно делать, когда лямбда-функция содержит только одно выражение, результат которого должен быть возвращен. В этом случае Java автоматически возвращает результат выражения без явного использования return

-- Ограничение на использование контекста --

Как и в случае циклов, мы можем внутри тела лямбда-функции использовать данные взятые из внешнего контекста, то есть определенные вне тела функции.

var n = 2;
temperatures.forEach((value) -> {
    System.out.println(value * n);
});

Но есть ограничение. В отличие от циклов, где с этими данными можно выполнять любые действия, лямбда-функции ограничены тем, что не могут изменять значение переменных, с которыми идет работа.

var n = 10;
temperatures.forEach((value) -> {
    System.out.println(value * n--); // ошибка
});

Подобный код приведет к ошибке: Local variable n defined in an enclosing scope must be final or effectively final







































