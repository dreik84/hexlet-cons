--- Введение в курс ---

Generics – это механизм языка программирования Java, который позволяет программистам убрать дублирование кода при реализации общего поведения для разных типов данных

--- Как работают дженерики ---

Тип данных определяет набор операций, который допустим для данного типа. Например, мы можем складывать числа, но не можем складывать булевы значения.

Однако, логика кода не всегда зависит от того, с каким типом данных происходит работа. Ярким примером служат коллекции, где большая часть операций никак не связана с типом данных, который находится внутри. Например, операция добавления элемента в список никак не затрагивает сам элемент. То же самое касается изменения, удаления и большей части остальных операций. Эти операции производятся над самой коллекцией, но сами элементы никак не обрабатываются.

-- Приведение к Object --

В Java все классы неявно наследуют класс Object. Любой объект можно привести к типу Object, а можно выполнить обратное преобразование.

Object value = "string";
// Методы строки работать не будут
// Error: cannot find symbol symbol: method toUpperCase()
value.toUpperCase();
// Здесь у нас снова обычная строка
var value2 = (String) value;
// Этот код работает
value2.toUpperCase();

Таким образом мы можем создать ровно один класс, хранящий в себе все данные в виде Object.

var items = new ArrayListOfObjects();
items.add("Sun");
// Требуется ручное преобразование
var value = (String) items.get(0);

У этого способа есть серьезный недостаток, это необходимость вручную следить за типами и как следствие, отсутствие типобезопасности. В такую коллекцию можно добавить любые данные, так как все типы в Java являются подтипами Object.

Все это привело к тому, что в языке появились дженерики, которые с одной стороны убирают дублирование кода, с другой обеспечивают типобезопасность. Концепция дженериков основана на понятии "параметр типа". То есть у типа (класса или интерфейса) появляется параметр, который тоже является типом. Этот параметр определяет то, с каким типом будет работать дженерик для конкретной ситуации, например, созданного объекта. Синтаксически, параметр типа указывается в угловых скобках во время создания объекта из дженерика.

// items1 работает только с числами
var items1 = new MyArrayList<Integer>();
// items2 работает только со строками
var items2 = new MyArrayList<String>();

Внутри это выглядит примерно так:

public class MyArrayList<T> {
    private Object[] data;
    private int size;

    public MyArrayList() {
        data = new Object[10];
        size = 0;
    }

    public void add(T value) {
        data[size++] = value;
    }

    public T get(int index) {
        // Приведение типа к T
        return (T) data[index];
    }
    // Остальные методы
}

После названия класса ставятся угловые скобки, внутри которых используется имя для параметра типа. Обычно пишут T, но это не обязательно. Внутри класса параметр типа используется там, где бы использовался обычный тип. Единственное исключение в случае коллекций заключается в том, что данные все равно надо хранить как объекты. Преобразование делается во время получения данных, внутри дженерика.

Программирование с использованием дженериков часто называют обобщенным программированием, а сами дженерики параметризуемыми типами. Так как дженериками выступают классы и интерфейсы, в которые как в методы передается параметр, только в отличие от методов, параметром является не значение какого-то типа, а сам тип.

--- Примеры встроенных дженериков ---

Для лучшего понимания дженериков, вспомним уже изученные и посмотрим на них еще раз уже новым взглядом.

-- Списки --

Все списки являются дженериками с одним параметром типа. Параметр можно указывать в правой части, как в примере ниже.

var items = new ArrayList<String>();

А можно задавать на уровне типа переменной, опуская указание в правой части.

List<String> items = new ArrayList<>();

Мы отдаем предпочтение первому методу, так как стараемся по возможности полагаться на вывод типов переменных через использование var.

-- Мапы --

В случае Map параметров типа уже два. Один для ключей другой для значений.

var codes = new HashMap<String, Integer>();

В остальном это такой же дженерик.

-- Функциональные интерфейсы --

В Java встроено множество функциональных интерфейсов для типовых операций, которые обычно используются внутри библиотек. 

// Дженерик
Predicate<Integer> isGreaterThanFive = number -> number > 5;

В случае лямбда-функций тип всегда указывается у переменной, поэтому здесь параметр типа передается в левой части выражения.

---  Реализация дженериков ---

Попрактикуемся в создании дженериков на примере такой коллекции как пара. Подобный тип данных встречается во многих языках и имитируется в Java с помощью мапы: Map.entry(key, value). Пара содержит два элемента, которые можно получить из пары и установить новые. 

-- Один параметр типа --

var point = new SimplePair<Integer>();

Для простоты наша пара будет работать с одним параметром типа, который определяет тип обоих значений в паре. Напишем соответствующий класс:

public class SimplePair<T> {

    private T left;
    private T right;

    public T getLeft() {
        return left;
    }

    public T getRight() {
        return right;
    }

    public void setLeft(T left) {
        this.left = left;
    }

    public void setRight(T right) {
        this.right = right;
    }
}

В угловых скобках указывается имя параметра, который будет передан внутрь при "вызове дженерика". Внутри этот параметр используется уже без скобок.

Синтаксически в определении методов ничего не поменялось, кроме того, что вместо конкретного типа мы подставляем параметр типа T. В случае геттеров мы возвращаем данные этого типа, в случае сеттеров - получаем на вход.

Теперь создадим дженерик-интерфейс, по аналогии с интерфейсом List.

public interface Pair<T> {

    public T getLeft();
    public T getRight();

    public void setLeft(T left);
    public void setRight(T right);
}
И реализуем его.

public class SimplePair<T> implements Pair<T> {
    // тут реализация
}

Параметр типа указывается и для класса и для интерфейса. В остальном в классе ничего не меняется. Сделав такое изменение, мы получаем возможность подменять реализацию.

-- Два параметра типа --

Изменим нашу пару так, чтобы тип каждого параметра выбирался независимо. Пример использования.

var pair = new SimplePair<String, Integer>();

Сначала поправим интерфейс.

public interface Pair<L, R> {

    public L getLeft();
    public R getRight();

    public void setLeft(L left);
    public void setRight(R right);
}

Следующий шаг поменять класс.

public class SimplePair<L, R> implements Pair<L, R> {

    private L left;
    private R right;

    // Добавляем конструктор по умолчанию
    // чтобы оставить возможность создавать пустую пару
    public SimplePair() {}
    public SimplePair(L left, R right) {
        this.left = left;
        this.right = right;
    }

    public L getLeft() {
        return left;
    }

    public R getRight() {
        return right;
    }

    public void setLeft(L left) {
        this.left = left;
    }

    public void setRight(R right) {
        this.right = right;
    }
}

И последнее, что мы сделаем, добавим конструктор, который позволяет передавать значения для пары в одну строку. Кроме того, в таком случае, компилятор автоматически выводит тип передаваемых значений, что позволяет не прописывать явно параметры типов.


























































