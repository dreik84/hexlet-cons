--- Введение в курс ---

Generics – это механизм языка программирования Java, который позволяет программистам убрать дублирование кода при реализации общего поведения для разных типов данных

--- Как работают дженерики ---

Тип данных определяет набор операций, который допустим для данного типа. Например, мы можем складывать числа, но не можем складывать булевы значения.

Однако, логика кода не всегда зависит от того, с каким типом данных происходит работа. Ярким примером служат коллекции, где большая часть операций никак не связана с типом данных, который находится внутри. Например, операция добавления элемента в список никак не затрагивает сам элемент. То же самое касается изменения, удаления и большей части остальных операций. Эти операции производятся над самой коллекцией, но сами элементы никак не обрабатываются.

-- Приведение к Object --

В Java все классы неявно наследуют класс Object. Любой объект можно привести к типу Object, а можно выполнить обратное преобразование.

Object value = "string";
// Методы строки работать не будут
// Error: cannot find symbol symbol: method toUpperCase()
value.toUpperCase();
// Здесь у нас снова обычная строка
var value2 = (String) value;
// Этот код работает
value2.toUpperCase();

Таким образом мы можем создать ровно один класс, хранящий в себе все данные в виде Object.

var items = new ArrayListOfObjects();
items.add("Sun");
// Требуется ручное преобразование
var value = (String) items.get(0);

У этого способа есть серьезный недостаток, это необходимость вручную следить за типами и как следствие, отсутствие типобезопасности. В такую коллекцию можно добавить любые данные, так как все типы в Java являются подтипами Object.

Все это привело к тому, что в языке появились дженерики, которые с одной стороны убирают дублирование кода, с другой обеспечивают типобезопасность. Концепция дженериков основана на понятии "параметр типа". То есть у типа (класса или интерфейса) появляется параметр, который тоже является типом. Этот параметр определяет то, с каким типом будет работать дженерик для конкретной ситуации, например, созданного объекта. Синтаксически, параметр типа указывается в угловых скобках во время создания объекта из дженерика.

// items1 работает только с числами
var items1 = new MyArrayList<Integer>();
// items2 работает только со строками
var items2 = new MyArrayList<String>();

Внутри это выглядит примерно так:

public class MyArrayList<T> {
    private Object[] data;
    private int size;

    public MyArrayList() {
        data = new Object[10];
        size = 0;
    }

    public void add(T value) {
        data[size++] = value;
    }

    public T get(int index) {
        // Приведение типа к T
        return (T) data[index];
    }
    // Остальные методы
}

После названия класса ставятся угловые скобки, внутри которых используется имя для параметра типа. Обычно пишут T, но это не обязательно. Внутри класса параметр типа используется там, где бы использовался обычный тип. Единственное исключение в случае коллекций заключается в том, что данные все равно надо хранить как объекты. Преобразование делается во время получения данных, внутри дженерика.

Программирование с использованием дженериков часто называют обобщенным программированием, а сами дженерики параметризуемыми типами. Так как дженериками выступают классы и интерфейсы, в которые как в методы передается параметр, только в отличие от методов, параметром является не значение какого-то типа, а сам тип.

--- Примеры встроенных дженериков ---

Для лучшего понимания дженериков, вспомним уже изученные и посмотрим на них еще раз уже новым взглядом.

-- Списки --

Все списки являются дженериками с одним параметром типа. Параметр можно указывать в правой части, как в примере ниже.

var items = new ArrayList<String>();

А можно задавать на уровне типа переменной, опуская указание в правой части.

List<String> items = new ArrayList<>();

Мы отдаем предпочтение первому методу, так как стараемся по возможности полагаться на вывод типов переменных через использование var.

-- Мапы --

В случае Map параметров типа уже два. Один для ключей другой для значений.

var codes = new HashMap<String, Integer>();

В остальном это такой же дженерик.

-- Функциональные интерфейсы --

В Java встроено множество функциональных интерфейсов для типовых операций, которые обычно используются внутри библиотек. 

// Дженерик
Predicate<Integer> isGreaterThanFive = number -> number > 5;

В случае лямбда-функций тип всегда указывается у переменной, поэтому здесь параметр типа передается в левой части выражения.

---  Реализация дженериков ---

Попрактикуемся в создании дженериков на примере такой коллекции как пара. Подобный тип данных встречается во многих языках и имитируется в Java с помощью мапы: Map.entry(key, value). Пара содержит два элемента, которые можно получить из пары и установить новые. 

-- Один параметр типа --

var point = new SimplePair<Integer>();

Для простоты наша пара будет работать с одним параметром типа, который определяет тип обоих значений в паре. Напишем соответствующий класс:

public class SimplePair<T> {

    private T left;
    private T right;

    public T getLeft() {
        return left;
    }

    public T getRight() {
        return right;
    }

    public void setLeft(T left) {
        this.left = left;
    }

    public void setRight(T right) {
        this.right = right;
    }
}

В угловых скобках указывается имя параметра, который будет передан внутрь при "вызове дженерика". Внутри этот параметр используется уже без скобок.

Синтаксически в определении методов ничего не поменялось, кроме того, что вместо конкретного типа мы подставляем параметр типа T. В случае геттеров мы возвращаем данные этого типа, в случае сеттеров - получаем на вход.

Теперь создадим дженерик-интерфейс, по аналогии с интерфейсом List.

public interface Pair<T> {

    public T getLeft();
    public T getRight();

    public void setLeft(T left);
    public void setRight(T right);
}
И реализуем его.

public class SimplePair<T> implements Pair<T> {
    // тут реализация
}

Параметр типа указывается и для класса и для интерфейса. В остальном в классе ничего не меняется. Сделав такое изменение, мы получаем возможность подменять реализацию.

-- Два параметра типа --

Изменим нашу пару так, чтобы тип каждого параметра выбирался независимо. Пример использования.

var pair = new SimplePair<String, Integer>();

Сначала поправим интерфейс.

public interface Pair<L, R> {

    public L getLeft();
    public R getRight();

    public void setLeft(L left);
    public void setRight(R right);
}

Следующий шаг поменять класс.

public class SimplePair<L, R> implements Pair<L, R> {

    private L left;
    private R right;

    // Добавляем конструктор по умолчанию
    // чтобы оставить возможность создавать пустую пару
    public SimplePair() {}
    public SimplePair(L left, R right) {
        this.left = left;
        this.right = right;
    }

    public L getLeft() {
        return left;
    }

    public R getRight() {
        return right;
    }

    public void setLeft(L left) {
        this.left = left;
    }

    public void setRight(R right) {
        this.right = right;
    }
}

И последнее, что мы сделаем, добавим конструктор, который позволяет передавать значения для пары в одну строку. Кроме того, в таком случае, компилятор автоматически выводит тип передаваемых значений, что позволяет не прописывать явно параметры типов.

--- Параметрический полиморфизм ---

Существует несколько видов полиморфизмов:

- Ad-hoc полиморфизм.
- Полиморфизм подтипов (subtyping).
- Параметрический полиморфизм.

Параметрический полиморфизм позволяет одному куску кода работать идентично для разных типов данных. Логика этого кода работает независимо от типа, для которого он выполняется. Например, логика кода добавления элемента в список никак не зависит от того, какого типа этот элемент.

var items = new LinkedList<>();
items.add("Sun");

Именно это и делают дженерики. Дженерики – это специфичное название для Java, но в его основе лежит параметрический полиморфизм. То есть дженерики – это реализация параметрического полиморфизма для Java. 

Программирование с использованием дженериков (или параметрического полиморфизма) называется обобщенным программированием (generic programming). Классы и интерфейсы называются обобщенными типами, а методы обобщенными методами. 

-- Производительность --

Параметрический полиморфизм – это теоретическое понятие, а дженерики – конкретная реализация. Поэтому, говоря о дженериках, нас, например, волнует такая вещь, как производительность. Насколько дженерики эффективны? Дженерики не создают нагрузку в рантайме. Компилятор генерирует нужные классы и интерфейсы для конкретных типов, что немного замедляет время компиляции, но на этом все. В результирующем коде все типы будут указаны явно. 

-- Отличие от ad-hoc полиморфизма --

Параметрический полиморфизм иногда путают с остальными видами, особенно с ad-hoc. ad-hoc полиморфизм в Java – это просто перегрузка методов.

class MathOperations {
    public int add(int a, int b) {
        return a + b;
    }

    // Перегруженный метод
    public double add(double a, double b) {
        return a + b;
    }
}

Перегрузка методов создает для каждого указанного типа свой собственный метод, поэтому не выполняется главное требование параметрического полиморфизма, в котором работает один кусок кода. Плюс перегрузка работает с ограниченным набором типов, в отличие от параметрического полиморфизма, для которого мы указываем обобщенный тип, подходящий подо все типы. 

--- Обобщенные методы ---

Методы, работающие с обобщенными типами, называются обобщенными методами.

public class SimplePair<L, R> implements Pair<L, R> {

    private L left;
    private R right;

    public L getLeft() {
        return left;
    }

    public R getRight() {
        return right;
    }
}

В отличие от самого класса, работа с такими методами не требует указания параметра типа, так как он уже был задан при создании объекта.

var pair = new SimplePair<String, String>();
pair.setLeft("hexlet");
pair.getLeft(); // hexlet

Дженерики могут выступать в качестве параметров типа. Как в качестве параметров метода, так и возвращаемого значения. 

-- Параметры типов у методов --

У обобщенных методов могут быть свои параметры типов, которых нет в классе. Это бывает нужно, когда мы хотим работать с параметром метода, тип которого может отличаться от параметра типа класса. В таком случае, в определение метода добавляется кусок кода с угловыми скобками перед типом возвращаемого значения.

public class SimplePair<L, R> {
    // остальные методы

    public <T> void doSomething(T element) {
        // какая-то логика
    }
}

Более того, обобщенные методы могут присутствовать в классах, которые не являются дженериками.

public class SomeClass {
    public <T> void doSomething(T element) {
        // какая-то логика
    }
}

--- Статические обобщенные методы ---

Дженериками могут быть не только классы и интерфейсы, но и статические методы. Как минимум один обобщенный статический метод нам уже известен:

// Реальный тип List<Integer>
var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
В отличие от обычных методов, статические методы не связаны с объектами классов, поэтому обобщенные статические методы существуют сами по себе, независимо от того, является ли класс дженериком или нет. При этом параметр типа у статических методов не указывается, так как он автоматически выводится на основе передаваемых данных. Из-за этого вызов обобщенных статических методов выглядит как вызов обычного метода. Разница же может проявляться тогда, когда вывод типа срабатывает не так, как нам бы того хотелось. В таком случае тип указывается в угловых скобках перед вызовом метода.

// Реальный тип List<Object>
var numbers = List.<Object>of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

Рассмотрим внутреннее устройство дженериков на примере статического метода identity(), который принимает на вход значение любого типа и возвращает его же наружу.

var value = App.identity("hexlet");
System.out.println(value); // hexlet

Его определение:

public class App {
    public static <T> T identity(T value) {
        return value;
    }
}

В определении метода произошло два изменения:

- Конкретные типы заменились на имя параметр типа
- После слова static добавился параметр типа в угловых скобках

-- Реальный пример --

В классе PairUtils реализуем статический метод аналогичный List.of(), который будет создавать новую пару. Начнем с примера использования.

// Возвращает SimplePair
var pair = PairUtils.getPair("hexlet", 100);
pair.getLeft(); // hexlet
pair.getRight(); // 100

Внутри метода мы работаем с конкретной парой, поэтому сама пара будет строиться на основе класса SimplePair.

public class PairUtils {
    static <L, R> SimplePair<L, R> getPair(L left, R right) {
        var pair = new SimplePair<L, R>();
        pair.setLeft(left);
        pair.setRight(right);
        return pair;
    }
}

Разберем подробнее, что здесь происходит:

- Добавлены параметры типа <L, R>
- В качестве возвращаемого значения указан дженерик SimplePair<L, R>, в который передаются параметры типа <L, R>.
- В теле создается объект из дженерика SimplePair, с передачей параметров типа метода getPair(). Этот код выглядит как передача параметров метода, во внутренний вызов метода.

--- Wildcard для спецификации подтипов ---

Дженерики позволяют нам работать однообразно с любым типом данных, но иногда возникает задача создать дженерик для определенного набора типов. Возьмем для примера задачу поиска среднего значения для списка чисел. Для Integer реализация метода выглядит так:

public class Application {
    public static Double average(List<Integer> numbers) {
        // Double
        var sum = 0.0;
        for (var number : numbers) {
            sum += number;
        }

        return sum / numbers.size();
    }

    public static void main(String[] args) {
        var numbers = List.of(1, 2, 3, 4, 5);
        System.out.println(average(numbers)); // => 3.0
    }
}

Если сделать из метода average() дженерик, то он не сработает, так как тип T будет Object, для которого операция сложения не определена.

Для подобных задач в Java есть механизм Wildcard, с его помощью можно уточнить типы, с которыми работает дженерик. В нашем случае и Integer и Double являются подтипами Number, а значит мы можем написать так: List<? extends Number>. В таком случае в метод попадут только числа, какими бы они не были, а типом параметра numbers станет List<Number>.

public static <T> Double average(List<? extends Number> numbers) {
    var sum = 0.0;
    for (var number : numbers) {
        sum += number.doubleValue();
    }

    return sum / numbers.size();
}

Wildcard не часто используется в прикладном коде, но часто используется в библиотеках. Поэтому его нужно знать на начальном этапе, хотя бы для того, чтобы читать документацию и понимать что там написано.