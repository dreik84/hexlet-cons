--- Введение ---

Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их количество на приемлемом уровне. 

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

- Модульные
- Интеграционные
- Системные

Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты.

Наиболее сложные и максимально эффективные — системные тесты. Они представляют из себя полную имитацию работы всей системы целиком. 

Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты.

--- Причины тестирования ---

Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.

-- Автоматические тесты --

 В Java есть специальный тип исключений, который принято "пробрасывать" при возникновении ошибок в тестах. Они называются AssertionError, что в дословном переводе означает "ошибка утверждения", т.е. вы в тестах что-то утверждали и, если это утверждение оказалось ошибочным, то пробрасывается AssertionError. 

throw new AssertionError("описание исключения");

Пример теста:

class StringUtilsTest {
    public static void testCapitalize() {
        // Если результат метода не равен ожидаемому значению
        if (!"Hello".equals(StringUtils.capitalize("hello"))) {
            // Выбрасываем исключение и завершаем выполнение теста
            throw new AssertionError("Метод работает неверно!");
        }
    }
}

Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой.

В коде, тесты складывают в директорию src/test.
Структура этой директории, обычно, повторяет структуру исходного кода.

-- Как пишутся тесты --

Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые методы, вызывать их с необходимыми аргументами и проверять, что методы возвращают ожидаемые значения.

Если поменялся контракт (входные данные или выход), то придётся переписывать тесты. Если контракт остался тем же, но поменялись внутренности метода, то тесты должны продолжать работать без изменений.

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

-- Сколько и какие нужно писать проверки? --

Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически неосуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

При написании тестов нужно ориентироваться на разнообразие входных данных. У любого метода есть один или несколько основных сценариев использования. Например, в случае capitalize — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка null
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария.

Комбинация всех возможных вариантов поведения метода называется цикломатической сложностью. Это число показывает все возможные пути кода внутри метода. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

--- Утверждения ---

Утверждения — ключевая часть тестов. Именно они проверяют работу кода:

// Первое утверждение (проверка на пустую строку)
if (!"".equals(StringUtils.capitalize(""))) {
    throw new AssertionError("Метод работает неверно!");
}

Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Java, начиная с версии 1.4., поддерживает ключевое слово assert, которое предназначено для проверки утверждений:

assert "Hello".equals(StringUtils.capitalize("hello")) : "Ваш метод не работает!";

В случае если значение после ключевого слова assert будет равно false, то возникнет ошибка (будет выброшено AssertionError). Другими словами, assert true означает что всё хорошо, а assert false говорит об ошибке.

Использование ключевого слова assert сделало наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

Однако, ключевое слово assert было введено только в Java 1.4., это значит что в предыдущих версиях Java вполне можно было создать переменную или метод с именем assert. Программы в которых использовались такие имена могли стать неработоспособными после введения нового ключевого слова. Для сохранения обратной совместимости было принято решение, что по умолчанию механизм использования assert будет отключен. Если нужно чтобы ваши assert срабатывали, то при запуске программы указывается аргумент командной строки -enableassertions (-ea).

--- Библиотека AssertJ ---

Встроенный в Java механизм проверки утверждений assert обладает рядом недостатков:

- Вы не можете быть уверены что он сработает в любой ситуации. Если запустить программу без аргумента -enableassertions (-ea), то проверки будут игнорироваться. Поэтому полагаться на assert в полной мере нельзя.
- Сами проверки сильно ограничены. После ключевого слова assert может быть только либо true, либо false, а это значит что вам необходимо сначала самостоятельно подготовить данные к проверке.
- Результат проверки неинформативен. Вам вернётся только сообщение об ошибке с указанием номера строки и имени класса в котором произошла ошибка. Да, есть вариант передать текстовое сообщение вместе с ошибкой, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий.

Сегодня мы рассмотрим библиотеку AssertJ, которая позволяет гораздо проще и удобнее писать тесты, а также получать достаточно информативный вывод об ошибках. При этом внутри будет всё равно лежать тот же самый механизм, который мы рассматривали в предыдущих уроках.

Точкой входа будет являться метод assertThat(), его можно импортировать вот так:

import static org.assertj.core.api.Assertions.assertThat;

Написание тестов с использованием библиотеки AssertJ отличается от использования ключевого слова assert и базируется на цепочке методов. Такой подход называется fluent API. Давайте рассмотрим пример теста, написанного с использованием этой библиотеки:

import static org.assertj.core.api.Assertions.assertThat;

class SomeClassTest {
    public static void testMethod() {
        var a = "Hello, world!";
        var b = "Hello, world!";

        assertThat(a).isEqualTo(b);
    }
}

Теперь тест превращается в связный текст на английском языке. В случае если утверждение окажется ложным, то будет выброшено AssertionFailedError из библиотеки org.opentest4j.AssertionFailedError.

--- Матчеры ---

Существует несколько популярных способов описывать утверждения. Кроме вызова обычных методов, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок. 

Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать.

int[] a = {1, 2, 3};
int[] b = {1, 2, 3};

// Проверка равенства по ссылке
// assert a == b;
assertThat(a).isSameAs(b); // false

// Проверка равенства по значению
// assert Arrays.equals(a, b);
assertThat(a).isEqualTo(b); // true

Любой матчер в AssertJ начинается с метода assertThat(data), в которую передаются данные на проверку. Затем assertThat возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. 

Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:

char[] data = {'a', 'b', 'c'};

// проверка, что размеры объектов совпадают
assertThat(data).hasSameSizeAs(new int[] {1, 2, 3});

// проверка, что не null
assertThat(data).isNotNull();

// проверка, что выражение равно true
assertThat(true).isTrue();

// проверка, что объект находится в перечне
assertThat(1).isIn(1, 2, 3, 4);

// проверка, что число находится в отрезке [a, b]
assertThat(9).isBetween(9, 11);

// проверка, что число находится в интервале (a, b)
assertThat(10).isStrictlyBetween(9, 11);


Кроме того, практически все матчеры обладают как "позитивной" так и "негативной" версией:

assertThat(data).isNull();
assertThat(data).isNotNull();

assertThat(true).isTrue();
assertThat(false).isFalse();

assertThat(1).isIn(1, 2, 3, 4);
assertThat(1).isNotIn(2, 3, 4, 5);

Библиотека AssertJ позволяет собирать несколько тестов в один вызов:

public static void testMethod() {
    var a = "Hello, world!";
    assertThat(a)                // утверждаем, что:
            .startsWith("Hello") // строка начинается с подстроки "Hello"
            .contains("llo, ")   // содержит строку "llo, "
            .endsWith("!");      // заканчивается строкой "!"
    }

Такие тесты выполняются последовательно. Если провалится одно утверждение, то следующие за ним уже проверяться не будут. Это становится очевидным, если вспомнить, что при провале теста пробрасывается исключение.

--- Модульные тесты ---

В этом уроке мы разберём основы модульного тестирования. Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: методы, пакеты, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

Попробуем протестировать стек. Стек представляет собой список элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, а извлекаются в обратном. 

// Стек встроен прямо в Java
import java.util.Stack;

public static void main(String[] args) {
    // Если вы не знакомы с дженериками, то не переживайте
    // Такой способ создания не влияет на использование
    // Он лишь нужен для указания типа данных, которые могут храниться в стеке
    Stack<Integer> stack = new Stack<>();

    // Проверка на пустоту
    stack.isEmpty();    // true;
    // Добавление в стек
    stack.push(1);      // (1)
    stack.push(2);      // (2, 1)
    stack.push(3);      // (3, 2, 1)
    stack.isEmpty();    // false
    // Извлечение из стека
    var value = stack.pop();        // 3. В стеке (2, 1)
    stack.pop();        // 2. В стеке (1)
    stack.pop();        // 1. В стеке пусто
    stack.isEmpty();    // true
}

-- Тестируем основную функциональность --

Теперь напишем первый тест. Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента:

import java.util.Stack;

class StackTest {
    public static void testStack() {
        Stack<Integer> stack = new Stack<>();
        // Добавляем два элемента в стек и затем извлекаем их
        stack.push(1);
        stack.push(2);
        // pop() возвращает последнее значение из стека
        // и удаляет его оттуда
        assertThat(stack.pop()).isEqualTo(2);
        assertThat(stack.pop()).isEqualTo(1);
    }
}

Этот тест проверяет, что правильно работают два основных метода без учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по очереди проверяют извлекаемые значения из стека.

-- Тестируем дополнительную функциональность --

Следующим тестом будет тест на дополнительные методы стека. К таким у нас относится метод isEmpty(), который проверяет, пустой ли стек:

import java.util.Stack;

class StackTest {
    public static void testStackIsEmpty() {
        Stack<Integer> stack = new Stack<>();
        assertThat(stack.isEmpty()).isTrue();
        stack.push(1);
        assertThat(stack.isEmpty()).isFalse();
        stack.pop();
        assertThat(stack.isEmpty()).isTrue();
    }
}

В этом тесте проверяются сразу три ситуации:

- начальное состояние стека
- состояние стека после добавления элементов
- состояние стека после извлечения всех элементов

В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых isEmpty() всё равно сломается. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. 

-- Пограничные случаи --

Ну, и последнее, что можно протестировать — поведение метода pop(), когда в стеке нет ни одного элемента. По задумке, стек выбрасывает исключение EmptyStackException, если из него попытались взять элемент, когда тот был пустой. В библиотеке AssertJ подобные проверки реализуются следующим образом:

// Основные импорты
import static org.assertj.core.api.Assertions.catchThrowable;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.Stack;
import java.util.EmptyStackException;

class StackTest {
    public static void testEmptyPop() {
        Stack<Integer> stack = new Stack<>();
        // Помещаем пробрасываемое исключение в переменную
        var thrown = catchThrowable(  // этот метод призван "ловить" исключения
            () -> stack.pop() // провоцируем исключительную ситуацию
        );
        // А теперь проверяем что мы поймали нужное исключение
        assertThat(thrown).isInstanceOf(EmptyStackException.class);
    }
}

Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, для которой не было теста, то сначала напишите тест, который воспроизводит эту ошибку, и затем уже чините её. Только так можно поддерживать достаточный уровень надежности, не превращая разработку в непрерывную починку багов.

--- JUnit ---

Когда тестов и файлов с тестами становится много, возникают новые вопросы. Как группировать тесты? Как запустить на выполнение все тесты из одной директории? Если их очень много и они долгие, можно ли запустить их параллельно?

Для решения этих вопросов используют специальные тестовые фреймворки. Они помогают организовать структуру тестов и дают много полезного, например, удобный вывод.

-- А что с AssertJ? --

AssertJ - отличная библиотека для тестов, но это именно библиотека. Она предоставляет большое количество классов и методов, с помощью которых вы можете делать проверки. Однако точкой входа в вашу программу и тесты останется всё тот же метод main(). То есть тестирование с AssertJ, в общем случае, становится неотъемлемой и неотделимой частью программы. Это просто методы, которые вызываются по ходу выполнения программы.

JUnit - это уже фреймворк. Он обладает своей собственной точкой входа (классом/методом, с которого начинается выполнение тестов), что делает его фактически второй программой, которая живёт отдельно от вашего основного кода. Это позволяет, в частности, не включать тесты в итоговую сборку проекта. 

-- Подключение --

JUnit интегрирован в процесс создания проекта на Gradle. Во время инициализации проекта, Gradle попросит выбрать тестовый фреймворк.

Теперь можно создавать классы и тестировать их. Создадим класс SomeClass со статическим методом sum(), который находит сумму двух чисел:

class SomeClass {
    public static int sum(int a, int b) {
        return a + b;
    }
}

Класс SomeClassTest.java с тестами для метода sum будет выглядеть следующим образом:

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class SomeClassTest {

    @Test
    public void testSum() {
        var expected = 5;
        var actual = SomeClass.sum(3, 2);
        assertEquals(expected, actual);
    }
}

Аннотация @Test "показывает" фреймворку, что этот метод является тестом, а класс Assertions является основным для большинства тестовых методов.

--- Подготовка данных ---

Большинство тестов на одну и ту же функциональность сильно похожи друг на друга. Особенно в части начальной подготовки данных. 
Фреймворк будет определять оптимальный порядок и способ запуска тестов. Пользователю при этом необходимо написать тесты, которые не будут зависеть друг от друга.
Для решения этой проблемы тестовые фреймворки предоставляют хуки — специальные методы, которые запускаются до или после тестов.

Аннотацией @BeforeEach помечаются методы, которые будут выполняться перед стартом каждого из тестовых методов. 

Если нам нужно выполнить код один раз перед всеми тестами, его нужно выполнять внутри метода с аннотацией @BeforeAll. Этот хук запускается ровно один раз перед всеми тестами, расположенными в одном классе. При этом сам метод, помеченный аннотацией @BeforeAll должен быть уже статичным.

Аналогично, существуют аннотации @AfterEach и @AfterAll, которые позволяют выполнить определённые действия после каждого или после всех тестов. Например, вы можете написать метод, который удалит созданный в начале файл.

Почему важно использовать аннотации, а не самостоятельно организовывать порядок и способ выполнения тестов? Самый простой ответ на этот вопрос такой: JUnit должен контролировать происходящие процессы и побочные эффекты в тестах. 

--- Плохие и хорошие практики тестирования ---

Тесты, как и любой другой код, можно писать по-разному, в том числе очень плохо. Помимо каких-то общих практик и стандартов кодирования у тестов есть свои особенности, о которых надо знать.

-- Взаимное влияние тестов --

Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.

-- Условные конструкции в тесте --

@Test
public void myTest() {
    if (/* что-нибудь */) {
        // Выполняем код одним способом
        // Проверка может быть тут
    } else {
        // Выполняем код другим способом
        // Проверка может быть тут
    }
}

Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста. От этого надо избавляться и никогда так не писать.

-- Тест вне тестов --

Задача @BeforeEach — готовить данные и среду для тестирования, а задача @Test — вызывать код, который тестируется, и проводить проверки. 

-- Слишком сильная детализация --

Программисты под влиянием голосов из интернета стремятся максимально разносить код по файлам, модулям и методам. То же самое наблюдается и в тестах. Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка.

Чаще всего, единственным результатом такого разделения будет большее количество кода и усложнение рефакторинга в будущем, когда тестов станет по-настоящему много.

-- Код с тестами писать дольше, чем код без тестов --

Это очень интересный вопрос, по которому можно понять, насколько хорошо программист умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки. И на это есть пять причин:

   - Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
   - Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
   - Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
   - Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
   - Тесты снижают уровень стресса.




























