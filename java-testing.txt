--- Введение ---

Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их количество на приемлемом уровне. 

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

- Модульные
- Интеграционные
- Системные

Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты.

Наиболее сложные и максимально эффективные — системные тесты. Они представляют из себя полную имитацию работы всей системы целиком. 

Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты.

--- Причины тестирования ---

Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.

-- Автоматические тесты --

 В Java есть специальный тип исключений, который принято "пробрасывать" при возникновении ошибок в тестах. Они называются AssertionError, что в дословном переводе означает "ошибка утверждения", т.е. вы в тестах что-то утверждали и, если это утверждение оказалось ошибочным, то пробрасывается AssertionError. 

throw new AssertionError("описание исключения");

Пример теста:

class StringUtilsTest {
    public static void testCapitalize() {
        // Если результат метода не равен ожидаемому значению
        if (!"Hello".equals(StringUtils.capitalize("hello"))) {
            // Выбрасываем исключение и завершаем выполнение теста
            throw new AssertionError("Метод работает неверно!");
        }
    }
}

Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой.

В коде, тесты складывают в директорию src/test.
Структура этой директории, обычно, повторяет структуру исходного кода.

-- Как пишутся тесты --

Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые методы, вызывать их с необходимыми аргументами и проверять, что методы возвращают ожидаемые значения.

Если поменялся контракт (входные данные или выход), то придётся переписывать тесты. Если контракт остался тем же, но поменялись внутренности метода, то тесты должны продолжать работать без изменений.

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

-- Сколько и какие нужно писать проверки? --

Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически неосуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

При написании тестов нужно ориентироваться на разнообразие входных данных. У любого метода есть один или несколько основных сценариев использования. Например, в случае capitalize — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка null
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария.

Комбинация всех возможных вариантов поведения метода называется цикломатической сложностью. Это число показывает все возможные пути кода внутри метода. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

--- Утверждения ---

Утверждения — ключевая часть тестов. Именно они проверяют работу кода:

// Первое утверждение (проверка на пустую строку)
if (!"".equals(StringUtils.capitalize(""))) {
    throw new AssertionError("Метод работает неверно!");
}

Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Java, начиная с версии 1.4., поддерживает ключевое слово assert, которое предназначено для проверки утверждений:

assert "Hello".equals(StringUtils.capitalize("hello")) : "Ваш метод не работает!";

В случае если значение после ключевого слова assert будет равно false, то возникнет ошибка (будет выброшено AssertionError). Другими словами, assert true означает что всё хорошо, а assert false говорит об ошибке.

Использование ключевого слова assert сделало наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

Однако, ключевое слово assert было введено только в Java 1.4., это значит что в предыдущих версиях Java вполне можно было создать переменную или метод с именем assert. Программы в которых использовались такие имена могли стать неработоспособными после введения нового ключевого слова. Для сохранения обратной совместимости было принято решение, что по умолчанию механизм использования assert будет отключен. Если нужно чтобы ваши assert срабатывали, то при запуске программы указывается аргумент командной строки -enableassertions (-ea).

--- Библиотека AssertJ ---

Встроенный в Java механизм проверки утверждений assert обладает рядом недостатков:

- Вы не можете быть уверены что он сработает в любой ситуации. Если запустить программу без аргумента -enableassertions (-ea), то проверки будут игнорироваться. Поэтому полагаться на assert в полной мере нельзя.
- Сами проверки сильно ограничены. После ключевого слова assert может быть только либо true, либо false, а это значит что вам необходимо сначала самостоятельно подготовить данные к проверке.
- Результат проверки неинформативен. Вам вернётся только сообщение об ошибке с указанием номера строки и имени класса в котором произошла ошибка. Да, есть вариант передать текстовое сообщение вместе с ошибкой, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий.

Сегодня мы рассмотрим библиотеку AssertJ, которая позволяет гораздо проще и удобнее писать тесты, а также получать достаточно информативный вывод об ошибках. При этом внутри будет всё равно лежать тот же самый механизм, который мы рассматривали в предыдущих уроках.

Точкой входа будет являться метод assertThat(), его можно импортировать вот так:

import static org.assertj.core.api.Assertions.assertThat;

Написание тестов с использованием библиотеки AssertJ отличается от использования ключевого слова assert и базируется на цепочке методов. Такой подход называется fluent API. Давайте рассмотрим пример теста, написанного с использованием этой библиотеки:

import static org.assertj.core.api.Assertions.assertThat;

class SomeClassTest {
    public static void testMethod() {
        var a = "Hello, world!";
        var b = "Hello, world!";

        assertThat(a).isEqualTo(b);
    }
}

Теперь тест превращается в связный текст на английском языке. В случае если утверждение окажется ложным, то будет выброшено AssertionFailedError из библиотеки org.opentest4j.AssertionFailedError.

--- Матчеры ---

Существует несколько популярных способов описывать утверждения. Кроме вызова обычных методов, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок. 

Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать.

int[] a = {1, 2, 3};
int[] b = {1, 2, 3};

// Проверка равенства по ссылке
// assert a == b;
assertThat(a).isSameAs(b); // false

// Проверка равенства по значению
// assert Arrays.equals(a, b);
assertThat(a).isEqualTo(b); // true

Любой матчер в AssertJ начинается с метода assertThat(data), в которую передаются данные на проверку. Затем assertThat возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. 

Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:

char[] data = {'a', 'b', 'c'};

// проверка, что размеры объектов совпадают
assertThat(data).hasSameSizeAs(new int[] {1, 2, 3});

// проверка, что не null
assertThat(data).isNotNull();

// проверка, что выражение равно true
assertThat(true).isTrue();

// проверка, что объект находится в перечне
assertThat(1).isIn(1, 2, 3, 4);

// проверка, что число находится в отрезке [a, b]
assertThat(9).isBetween(9, 11);

// проверка, что число находится в интервале (a, b)
assertThat(10).isStrictlyBetween(9, 11);


Кроме того, практически все матчеры обладают как "позитивной" так и "негативной" версией:

assertThat(data).isNull();
assertThat(data).isNotNull();

assertThat(true).isTrue();
assertThat(false).isFalse();

assertThat(1).isIn(1, 2, 3, 4);
assertThat(1).isNotIn(2, 3, 4, 5);

Библиотека AssertJ позволяет собирать несколько тестов в один вызов:

public static void testMethod() {
    var a = "Hello, world!";
    assertThat(a)                // утверждаем, что:
            .startsWith("Hello") // строка начинается с подстроки "Hello"
            .contains("llo, ")   // содержит строку "llo, "
            .endsWith("!");      // заканчивается строкой "!"
    }

Такие тесты выполняются последовательно. Если провалится одно утверждение, то следующие за ним уже проверяться не будут. Это становится очевидным, если вспомнить, что при провале теста пробрасывается исключение.

--- Модульные тесты ---

В этом уроке мы разберём основы модульного тестирования. Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: методы, пакеты, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

Попробуем протестировать стек. Стек представляет собой список элементов организованных по принципу LIFO. Данные кладутся в стек в одном порядке, а извлекаются в обратном. 

// Стек встроен прямо в Java
import java.util.Stack;

public static void main(String[] args) {
    // Если вы не знакомы с дженериками, то не переживайте
    // Такой способ создания не влияет на использование
    // Он лишь нужен для указания типа данных, которые могут храниться в стеке
    Stack<Integer> stack = new Stack<>();

    // Проверка на пустоту
    stack.isEmpty();    // true;
    // Добавление в стек
    stack.push(1);      // (1)
    stack.push(2);      // (2, 1)
    stack.push(3);      // (3, 2, 1)
    stack.isEmpty();    // false
    // Извлечение из стека
    var value = stack.pop();        // 3. В стеке (2, 1)
    stack.pop();        // 2. В стеке (1)
    stack.pop();        // 1. В стеке пусто
    stack.isEmpty();    // true
}

-- Тестируем основную функциональность --

Теперь напишем первый тест. Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента:

import java.util.Stack;

class StackTest {
    public static void testStack() {
        Stack<Integer> stack = new Stack<>();
        // Добавляем два элемента в стек и затем извлекаем их
        stack.push(1);
        stack.push(2);
        // pop() возвращает последнее значение из стека
        // и удаляет его оттуда
        assertThat(stack.pop()).isEqualTo(2);
        assertThat(stack.pop()).isEqualTo(1);
    }
}

Этот тест проверяет, что правильно работают два основных метода без учёта пограничных случаев. Для этого внутри теста выполняются два матчера, которые по очереди проверяют извлекаемые значения из стека.

-- Тестируем дополнительную функциональность --

Следующим тестом будет тест на дополнительные методы стека. К таким у нас относится метод isEmpty(), который проверяет, пустой ли стек:

import java.util.Stack;

class StackTest {
    public static void testStackIsEmpty() {
        Stack<Integer> stack = new Stack<>();
        assertThat(stack.isEmpty()).isTrue();
        stack.push(1);
        assertThat(stack.isEmpty()).isFalse();
        stack.pop();
        assertThat(stack.isEmpty()).isTrue();
    }
}

В этом тесте проверяются сразу три ситуации:

- начальное состояние стека
- состояние стека после добавления элементов
- состояние стека после извлечения всех элементов

В принципе, этого достаточно. Хотя в теории возможны ситуации, при которых isEmpty() всё равно сломается. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. 

-- Пограничные случаи --

Ну, и последнее, что можно протестировать — поведение метода pop(), когда в стеке нет ни одного элемента. По задумке, стек выбрасывает исключение EmptyStackException, если из него попытались взять элемент, когда тот был пустой. В библиотеке AssertJ подобные проверки реализуются следующим образом:

// Основные импорты
import static org.assertj.core.api.Assertions.catchThrowable;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.Stack;
import java.util.EmptyStackException;

class StackTest {
    public static void testEmptyPop() {
        Stack<Integer> stack = new Stack<>();
        // Помещаем пробрасываемое исключение в переменную
        var thrown = catchThrowable(  // этот метод призван "ловить" исключения
            () -> stack.pop() // провоцируем исключительную ситуацию
        );
        // А теперь проверяем что мы поймали нужное исключение
        assertThat(thrown).isInstanceOf(EmptyStackException.class);
    }
}

Но не всегда пограничные случаи так легко увидеть. Маловероятно, что любой программист сможет сразу написать все нужные тесты. Если в коде возникла ошибка, для которой не было теста, то сначала напишите тест, который воспроизводит эту ошибку, и затем уже чините её. Только так можно поддерживать достаточный уровень надежности, не превращая разработку в непрерывную починку багов.




































