--- Введение ---

Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их количество на приемлемом уровне. 

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

- Модульные
- Интеграционные
- Системные

Самые простые и наименее эффективные тесты — модульные. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе. За это уже отвечают интеграционные тесты.

Наиболее сложные и максимально эффективные — системные тесты. Они представляют из себя полную имитацию работы всей системы целиком. 

Несмотря на различия, в основе всех автоматических тестов лежат одни и те же принципы. Часто используются одни и те же инструменты.

--- Причины тестирования ---

Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.

-- Автоматические тесты --

 В Java есть специальный тип исключений, который принято "пробрасывать" при возникновении ошибок в тестах. Они называются AssertionError, что в дословном переводе означает "ошибка утверждения", т.е. вы в тестах что-то утверждали и, если это утверждение оказалось ошибочным, то пробрасывается AssertionError. 

throw new AssertionError("описание исключения");

Пример теста:

class StringUtilsTest {
    public static void testCapitalize() {
        // Если результат метода не равен ожидаемому значению
        if (!"Hello".equals(StringUtils.capitalize("hello"))) {
            // Выбрасываем исключение и завершаем выполнение теста
            throw new AssertionError("Метод работает неверно!");
        }
    }
}

Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой.

В коде, тесты складывают в директорию src/test.
Структура этой директории, обычно, повторяет структуру исходного кода.

-- Как пишутся тесты --

Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые методы, вызывать их с необходимыми аргументами и проверять, что методы возвращают ожидаемые значения.

Если поменялся контракт (входные данные или выход), то придётся переписывать тесты. Если контракт остался тем же, но поменялись внутренности метода, то тесты должны продолжать работать без изменений.

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

-- Сколько и какие нужно писать проверки? --

Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически неосуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

При написании тестов нужно ориентироваться на разнообразие входных данных. У любого метода есть один или несколько основных сценариев использования. Например, в случае capitalize — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка null
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария.

Комбинация всех возможных вариантов поведения метода называется цикломатической сложностью. Это число показывает все возможные пути кода внутри метода. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

--- Утверждения ---

Утверждения — ключевая часть тестов. Именно они проверяют работу кода:

// Первое утверждение (проверка на пустую строку)
if (!"".equals(StringUtils.capitalize(""))) {
    throw new AssertionError("Метод работает неверно!");
}

Можно заметить, что все проверки строятся одинаковым способом: условие => исключение. Java, начиная с версии 1.4., поддерживает ключевое слово assert, которое предназначено для проверки утверждений:

assert "Hello".equals(StringUtils.capitalize("hello")) : "Ваш метод не работает!";

В случае если значение после ключевого слова assert будет равно false, то возникнет ошибка (будет выброшено AssertionError). Другими словами, assert true означает что всё хорошо, а assert false говорит об ошибке.

Использование ключевого слова assert сделало наш код короче и проще для восприятия. Положительная проверка смотрится естественнее, так как это то, что мы ожидаем.

Однако, ключевое слово assert было введено только в Java 1.4., это значит что в предыдущих версиях Java вполне можно было создать переменную или метод с именем assert. Программы в которых использовались такие имена могли стать неработоспособными после введения нового ключевого слова. Для сохранения обратной совместимости было принято решение, что по умолчанию механизм использования assert будет отключен. Если нужно чтобы ваши assert срабатывали, то при запуске программы указывается аргумент командной строки -enableassertions (-ea).

--- Библиотека AssertJ ---

Встроенный в Java механизм проверки утверждений assert обладает рядом недостатков:

- Вы не можете быть уверены что он сработает в любой ситуации. Если запустить программу без аргумента -enableassertions (-ea), то проверки будут игнорироваться. Поэтому полагаться на assert в полной мере нельзя.
- Сами проверки сильно ограничены. После ключевого слова assert может быть только либо true, либо false, а это значит что вам необходимо сначала самостоятельно подготовить данные к проверке.
- Результат проверки неинформативен. Вам вернётся только сообщение об ошибке с указанием номера строки и имени класса в котором произошла ошибка. Да, есть вариант передать текстовое сообщение вместе с ошибкой, но так не делают, потому что это слишком "ручной" способ, требующий больших усилий.

Сегодня мы рассмотрим библиотеку AssertJ, которая позволяет гораздо проще и удобнее писать тесты, а также получать достаточно информативный вывод об ошибках. При этом внутри будет всё равно лежать тот же самый механизм, который мы рассматривали в предыдущих уроках.

Точкой входа будет являться метод assertThat(), его можно импортировать вот так:

import static org.assertj.core.api.Assertions.assertThat;

Написание тестов с использованием библиотеки AssertJ отличается от использования ключевого слова assert и базируется на цепочке методов. Такой подход называется fluent API. Давайте рассмотрим пример теста, написанного с использованием этой библиотеки:

import static org.assertj.core.api.Assertions.assertThat;

class SomeClassTest {
    public static void testMethod() {
        var a = "Hello, world!";
        var b = "Hello, world!";

        assertThat(a).isEqualTo(b);
    }
}

Теперь тест превращается в связный текст на английском языке. В случае если утверждение окажется ложным, то будет выброшено AssertionFailedError из библиотеки org.opentest4j.AssertionFailedError.

--- Матчеры ---

Существует несколько популярных способов описывать утверждения. Кроме вызова обычных методов, популярностью пользуются "матчеры", которые внешне выглядят как мини-язык для описания проверок. 

Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. Это даёт возможность использовать их как документацию людям, которые не умеют программировать.

int[] a = {1, 2, 3};
int[] b = {1, 2, 3};

// Проверка равенства по ссылке
// assert a == b;
assertThat(a).isSameAs(b); // false

// Проверка равенства по значению
// assert Arrays.equals(a, b);
assertThat(a).isEqualTo(b); // true

Любой матчер в AssertJ начинается с метода assertThat(data), в которую передаются данные на проверку. Затем assertThat возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. 

Ниже пример некоторых популярных матчеров, полезных в ежедневном тестировании:

char[] data = {'a', 'b', 'c'};

// проверка, что размеры объектов совпадают
assertThat(data).hasSameSizeAs(new int[] {1, 2, 3});

// проверка, что не null
assertThat(data).isNotNull();

// проверка, что выражение равно true
assertThat(true).isTrue();

// проверка, что объект находится в перечне
assertThat(1).isIn(1, 2, 3, 4);

// проверка, что число находится в отрезке [a, b]
assertThat(9).isBetween(9, 11);

// проверка, что число находится в интервале (a, b)
assertThat(10).isStrictlyBetween(9, 11);


Кроме того, практически все матчеры обладают как "позитивной" так и "негативной" версией:

assertThat(data).isNull();
assertThat(data).isNotNull();

assertThat(true).isTrue();
assertThat(false).isFalse();

assertThat(1).isIn(1, 2, 3, 4);
assertThat(1).isNotIn(2, 3, 4, 5);

Библиотека AssertJ позволяет собирать несколько тестов в один вызов:

public static void testMethod() {
    var a = "Hello, world!";
    assertThat(a)                // утверждаем, что:
            .startsWith("Hello") // строка начинается с подстроки "Hello"
            .contains("llo, ")   // содержит строку "llo, "
            .endsWith("!");      // заканчивается строкой "!"
    }

Такие тесты выполняются последовательно. Если провалится одно утверждение, то следующие за ним уже проверяться не будут. Это становится очевидным, если вспомнить, что при провале теста пробрасывается исключение.







































