--- О курсе ---

Обычно под термином API подразумевают способ, с помощью которого программы или сервисы могут запрашивать данные у других сервисов. 

HTTP — это самый распространенный и удобный способ делать API для публичных интернет сервисов. Под него заточен весь интернет, он поддерживается в любом языке программирования.

--- Для чего используется HTTP API ---

Не каждый сайт имеет API. К примеру визитки компаний, информационные сайты, каталоги содержат лишь набор статических HTML-страниц с текстом. 

-- Мобильные приложения --

Большинство мобильных приложений — это всего лишь «окно» в серверную часть, то есть бэкенд. Так работают сервисы бронирования, переводов, карты, мессенджеры, социальные сети, приложения для бизнеса.

-- Фронтенд на JavaScript --

Когда мы загружаем любой сайт в интернете, то возможны два варианта, по которым формируется внешний вид страницы в браузере.

Вариант 1. HTML-страницы формируются на сервере и отдаются в браузер напрямую. 
Вариант 2. Загруженная страница содержит JavaScript, который отслеживает и перехватывает клики по кнопкам и другие события. 

-- Сервисы для сервисов --

Большая область применения HTTP API скрыта от пользователей. Современные веб-сервисы взаимодействуют с множеством других систем, получают от них нужные данные или возможности. Все это происходит на сервере и не доходит до пользователя в браузер или мобильное приложение.

--- HTTP-запросы в браузере ---

Проще всего увидеть использование HTTP API прямо в браузере. Для удобства разработки и тестирования браузеры включают в себя панель разработчика — с ее помощью можно полностью проанализировать страницу, процессы, происходящие внутри и HTTP-запросы.

-- Chrome DevTools --

Здесь нас интересует вкладка Network. На ней отображаются все запросы, которые выполняет браузер в процессе загрузки страницы. 

Чтобы отделить запросы к HTTP API от всего остального, на вкладке Network нужно нажать кнопку Fetch/XHR. Тогда в списке загружаемых ресурсов останутся ресурсы с типом xhr. Это и есть запросы к HTTP API.

--- Пример HTTP API ---

HTTP API может быть очень разным и по возможностям, и по внутреннему устройству данных.

Обычно HTTP API построен по следующим правилам:
- Данные передаются в формате JSON
- Для каждого набора данных используется свой URL

Это далеко не единственный способ организации HTTP API, но один из самых распространенных.

В документации сервиса описываются ресурсы — сущности, информацию о которых мы можем получать по API. 

Каждая ссылка, по которой мы получаем какие-то данные в HTTP API, называется эндпоинтом.

Формат — это способ описания данных. С ним можно работать двумя способами:
- упаковать данные — то есть сериализовать их
- извлечь данные — десериализовать их

Задача сериализации и десериализации возникает тогда, когда нам нужно передать данные из программы наружу — например, другим программам.

Данные внутри языков представляются каким-то способом, специфичным для данного языка и даже его конкретной версии. Поэтому для передачи данных и используются универсальные форматы, которые известны всем.

В случае HTTP API этот механизм работает так:
- Сервис, который предоставляет HTTP API, извлекает данные из хранилища, формирует JSON и отдает его наружу
- Затем этот JSON может прочитать любая программа с поддержкой JSON

Поддержка JSON часто реализована прямо на уровне языков программирования. JSON — это всего лишь текст. У него есть понятная структура, которая прослеживается визуально. Отступы, пробелы и переносы для JSON не имеют значения.

JSON — это не единственный формат данных. До него популярным форматом был XML, и сейчас он встречается довольно часто. 
XML похож на HTML, но решает другую задачу. XML — это формат данных, как и JSON. Разница лишь в том, что XML не предназначен для вывода.

-- Структура JSON --

Данные в формате JSON хранятся внутри объектов. Объект — это часть данных, ограниченная фигурными скобками, внутри которых задаются ключи и их значения.

{ "id": 3, "hasBranches": true, "name": "Hexlet", "country": "Finland" }

Ключи в JSON всегда обернуты кавычками. В качестве значений могут выступать числа, булевы значения, строки и null. 
Также значениями могут быть массивы. Объекты могут быть вложенными в другие объекты или массивы.

-- Метаданные --

Часто нужно передавать не только данные, но и метаданные — то есть данные о данных. Например, к метаданным относится общее количество пользователей. 

{
    "users": [],
    "total": 100,
}

Объект позволяет добавлять новые данные, сохраняя обратную совместимость в структуре, не ломая ее.

-- Пагинация --

Иногда данных слишком много: JSON с таким объемом данных получится огромным и тяжелым.
Для решения этой задачи используют пагинацию — с ней данные отдаются не целиком, а небольшими наборами.

{
    "posts": [...],
    "total": 100,
    "skip": 30,
    "limit": 30
}

-- Ограничение данных --

Представим, что нам нужны не все данные, а только их часть. Для этого в нашем HTTP API есть параметр запроса select.

-- Одиночный ресурс --

Эндпоинт /users возвращает список пользователей. Если нам нужен один пользователь, то для этого понадобится другой эндпоинт — /users/:id.

Этот эндпоинт называется динамическим, потому что у него есть меняющаяся часть. Вместо :id подставляется идентификатор конкретного пользователя, данные которого мы хотим получить.

-- Вложенные ресурсы --

Чтобы увидеть посты конкретного пользователя, мы воспользуемся вложенными ресурсами: https://http.hexlet.app/http-api/users/1/posts.

--- CRUD ---

В программировании часто используется аббревиатура CRUD ( Create, Read, Update, Delete ). Она обозначает четыре базовых операции над информацией:

- Создание
- Чтение
- Обновление
- Удаление

CRUD строят вокруг какой-то сущности. Для этого создают либо интерфейс с формами, либо HTTP API эндпоинты. 

Посмотрим на пример данных для сущности "задача":

Метод	URL	        Операция
GET	/tasks	        Список задач
GET	/tasks/1	Информация о задаче
POST	/tasks	        Добавление задачи
PATCH	/tasks/1	Обновление задачи
DELETE	/tasks/1	Удаление задачи

Как видите, в URL постоянно повторяется 1 — это идентификатор конкретной задачи. Он будет меняться в зависимости от того, с какой задачей мы работаем прямо сейчас.

У HTTP методов есть определенный смысл:

- GET нужен для извлечения данных
- POST — для создания и отправки форм
- PATCH — для обновления
- DELETE — для удаления

В API важно использовать подходящие методы. Любые HTTP-запросы обрабатываются веб-серверами и промежуточными прокси. В зависимости от параметров запроса они могут делать различные оптимизации и кешировать результат.

Кеширование — это такая техника, которая позволяет веб-серверу или прокси сохранить ответ от сервера и отдавать его при следующих запросах без обращения к самому серверу.

Кеширование ускоряет доступ к ресурсам и разгружает серверы. 
Результат (ответ) на GET запрос можно кэшировать, для ускорения доступа, потому что GET запрос не должен менять данные. 
Методы POST, PATCH и DELETE кешировать нельзя — они должны постоянно приходить на сервер, так как они вносят изменения.

-- Добавление задачи --

Для добавления задачи нам нужно отправить POST-запрос на эндпоинт https://http.hexlet.app/http-api/tasks.

Данные можно отправлять в разных форматах, HTML-формой или JSON-файлом. 
Чтобы использовать JSON, во время подготовки запроса нужно выполнить два шага:

- Указать заголовок Content-Type со значением application/json
- Преобразовать данные в JSON

Есть несколько возможных вариантов ответа от сервера:

Код 201 — ресурс успешно создан
Код 422 — ошибка валидации
Код 406 — некорректные данные или неверный формат

-- Обновление задачи --

Для обновления задачи мы должны отправить PATCH-запрос на эндпоинт https://http.hexlet.app/http-api/tasks/:id

Если все прошло успешно, то возможны два варианта ответа:

Код 200 с какими-то данными — например, JSON с обновленными данными ресурса
Код 204 — нет тела ответа

-- Удаление задачи --

Для удаления задачи мы должны отправить DELETE-запрос на эндпоинт https://http.hexlet.app/http-api/tasks/:id

Если все прошло успешно, то возможны два варианта ответа:

Код 200 и какие-то данные
Код 204 и пустое тело ответа

-- Идемпотентность --

Когда мы работаем с API, очень важна идемпотентность запросов. Это свойство указывает, насколько безопасно выполнять HTTP-вызов повторно. Идемпотентный запрос приводит к одному и тому же результату независимо от количества сделанных вызовов.

Для примера возьмем эндпоинт /tasks. Он возвращает список задач и ничего не меняет на сервере. Каждый новый вызов этого эндпоинта возвращает идентичный список задач — значит, это идемпотентный запрос.

А вот POST-запрос — точно не идемпотентный. Каждый вызов /tasks имеет два исхода:

- добавляет новую задачу, хотя и с теми же самыми данными
- возвращает ошибку, если на сервере добавлена проверка на уникальность каких-то данных

По стандарту PATCH тоже не идемпотентный, хотя на практике чаще его делают идемпотентным. 

Самое интересное — это DELETE. По стандарту он идемпотентный, то есть повторное удаление уже удаленного ресурса должно возвращать код 204 по спецификации HTTP. На практике об этом знают далеко не все программисты, поэтому обычно повторное удаление приводит к ошибке 404.

Идемпотентность по стандарту закреплена за методами HTTP в спецификации. Но на практике все может работать иначе. Нельзя с уверенностью сказать, насколько конкретное HTTP API соответствует этим правилам. 

--- HTTPie ---

При работе с API важно иметь под рукой удобный инструмент для выполнения HTTP-запросов. Одним из таких инструментов является утилита командной строки HTTPie.

Знакомство с утилитой начнем с отправки простого GET запроса:

http https://http.hexlet.app/http-api/example

Если нам нужно увидеть только тело ответа, можно использовать опцию -b:

http -b http.hexlet.app/http-api/example

Если нужно увидеть не только ответ, но и запрос, то понадобится флаг -v или --verbose. Он покажет все взаимодействие — и запрос и ответ:

http -v https://http.hexlet.app/http-api/example

-- Параметры строки запроса --

Нам может понадобиться отправить дополнительные данные на сервер в параметрах строки запроса. Чтобы не формировать строку вручную, мы можем передать параметры в виде пар ключ-значение, используя синтаксис param==value. HTTPie автоматически распарсит их и сформирует строку запроса:

# Используем опцию -v чтобы увидеть запрос
http -v https://http.hexlet.app/http-api/users skip==3 limit==1

-- HTTP метод --

Утилита по умолчанию использует метод GET для запросов без тела и POST для запросов с телом. При этом утилита никак не ограничивает нас в самостоятельном выборе HTTP метода. Если нужно использовать другой метод, его имя указывается непосредственно перед аргументом URL:

http HEAD http.hexlet.app/http-api/example

-- Отправка заголовков --

Чтобы передать собственный заголовок в запросе, используется синтаксис Header:Value

http -v https://http.hexlet.app/http-api/example X-Custom-Header:value X-Foo:Bar

-- Указание тела в запросе --

Утилита предоставляет удобный способ передать данные на сервер в теле запроса. Мы можем указать поля с данными в виде пар "ключ-значение" при помощи синтаксиса key=value.

Поскольку JSON очень распространен в современных веб-сервисах, он используется в HTTPie как тип контента по умолчанию. Эти поля будут автоматически сериализованы как JSON-объект, что избавляет нас от необходимости его ручного составления. При этом HTTPie автоматически установит тип контента (заголовок Content-Type) application/json

Если нам понадобится отправить эти данные в виде формы, нужно будет использовать опцию -f или --form. Данные будут сериализованы как форма, а тип контента автоматически будет установлен application/x-www-form-urlencoded

При необходимости можно передать и "сырое" тело. Это делается при помощи опции --raw. Данные будут переданы на сервер как есть, без какого-либо преобразования:

http -v --raw 'Hello!' https://http.hexlet.app/http-api/echo

По сравнению с curl, который часто применяется в скриптах и автоматизации, HTTPie предлагает более интуитивно понятный синтаксис и читабельный вывод.






































