 Инструкции (Statements):

Инструкция — это команда для компьютера. Код на Java — это набор инструкций, которые, обычно, отделяются друг от друга символом ;

Инструкция — это единица исполнения. Программа, которая запускает код на Java, выполняет инструкции строго по очереди. 

Инструкции ― каркас программы, к ним относят условные конструкции, циклы и классы. Например, if, if-else, while, for. Они задают маршрут, по которому компьютер будет обрабатывать код, но сами никаких действий не производят и не возвращают результат.

Выражения:

Выражение — нечто возвращающее результат, который можно использовать.
Выражения в Java состоят из операндов и операторов. 
Любая строка — выражение. Причем и конкатенация строк — тоже выражение. Когда программа видит выражение, она вычисляет его и возвращает результат.

Операторы:

Операторы — это команды, которые указывают компьютеру, какие действия нужно совершить над операндами. 

Оператор — просто символ, который выполняет операцию.  + — это оператор, а числа 8 и 2 — это операнды.
Операции, которые требуют наличия двух операндов, называются бинарными. Бывают еще: Унарные — с одним операндом и Тернарные — с тремя операндами.
Бинарная операция считается коммутативной, если вы получаете тот же самый результат, поменяв местами операнды. 

Приоритеты операторов - В языке Java последовательность выполнения операций выстроена так, чтобы соблюсти правила арифметики. ???

\n — это пример экранирующей последовательности (escape sequence). Их еще называют управляющими конструкциями.
Операция соединения строк в программировании называется конкатенацией.

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить в начале. Имена переменных регистрозависимы.
Java — статически типизированный язык. Это значит, что тип переменной задается при определении и больше не меняется.
Java — язык со строгой типизацией. Проще говоря, любой переменной необходимо присваивать тип данных.
Любая переменная может быть частью любого выражения. В момент вычисления вместо имени переменной подставляется ее значение.

Именование переменных:
kebab-case — составные части переменной разделяются дефисом (my-super-var)
snake_case — для разделения используется подчеркивание (my_super_var)
CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
lowerCamelCase — каждое слово в переменной пишется с заглавной буквы, кроме первого (mySuperVar)

В Java используется CamelCase и его вариация lowerCamelCase, при котором первая буква первого слова — строчная.

Магические числа (magic numbers) — числа, происхождение которых невозможно понять без глубокого знания происходящего внутри участка кода.

Типы определяют две вещи:
- Допустимые значения.
- Набор допустимых операций.

var – специальное ключевое слово, которое включает механизм вывода типов. Вывод типов автоматически определяет тип присваиваемого значения и связывает его с переменной. 

Глобально, типы данных в Java делятся на две большие группы:
Примитивные — предопределены в Java. Примитивные данные всегда имеют значение, даже если они определяются без инициализации. Примитивные данные сравниваются по значению.
Ссылочные — создаются самим программистом, за исключением String и Array. У ссылочных в качестве значения по умолчанию используется null. Ссылочные сравниваются по ссылкам. 

Всего в Java восемь примитивных типов данных:

byte
short
int
long
float
double
boolean
char

Особняком в Java стоит значение null. В Java оно не является типом. Это просто конкретное значение со специальным смыслом и логикой работы.
Любой ссылочный тип данных может принимать значение null. А вот примитивные типы и null не совместимы. Примитивное значение всегда должно быть определено.

Значение по умолчанию

Явное преобразование типов (cast)
Неявное преобразование типов - автоматическое преобразование типов без явного указания программистом.

Функции — одна из ключевых конструкций в программировании. Все функции Java создаются только внутри классов, которые мы пока не разбирали. А функции, которые определены внутри классов, принято называть методами.
Методы — это действия, которые нужно выполнить над данными, к которым они применяются.
В вызовы методов можно передавать параметры.

Синтаксические ошибки - нарушают правила синтаксиса языка. Эти ошибки обнаруживаются на этапе компиляции, до реального запуска.
Ошибки типов - процесс проверки соответствия типов выполняется на этапе компиляции до запуска программы на выполнение.
Ошибки выполнения - возникают в процессе работы. Такие ошибки базируются на механизме исключения (exceptions).
Логические ошибки - ошибки, которые не приводят к остановке программы. То есть программа работает, но ее результат не соответствует ожидаемому.
Ошибки линтера - код на соответствие стандартам кодирования (checkstyle).Соблюдение данных правил не влияет на результат, но помогает писать код понятнее и проще для восприятия.

Строки в Java неизменяемы. Не существует способа и методов, способных изменить саму строку. Любой метод строки может только вернуть новую строку.

Детерминированность
Метод называется детерминированным тогда, когда для одних и тех же входных параметров он возвращает один и тот же результат. 

Побочным эффектом называют действия, которые соприкасаются с внешним окружением. К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран, печать на принтере и так далее.

return – это особая инструкция. Она берет выражение справа и отдает его наружу тому коду, который вызвал метод. Как только Java натыкается на return, выполнение метода на этом завершается.

Параметры методов в Java всегда обязательны. 
В отличие от других языков, в Java нет возможности задать значение параметров по умолчанию, но ее можно имитировать с помощью перегрузки методов.
Java позволяет создать несколько методов с одинаковым именем. У таких одинаковых методов должно выполняться одно из условий:
	- Разные типы входных параметров
	- Разное количество параметров
	- Все перечисленное выше одновременно

Перегрузка методов может приводить к дублированию кода. Для снижения дублирования достаточно сделать два шага:
	- Сначала определить общий метод, который принимает больше всего параметров
	- Затем вызывать его из тех методов, где есть значения по умолчанию

Как и во многих других языках, в Java все данные делятся на два больших типа:
	- Примитивные данные сравниваются по значению, независимо от адресов
	- Ссылочные данные сравниваются по адресам

Область математики, в которой изучаются логические операторы, называется булевой алгеброй.
Наряду с конъюнкцией (И) и дизъюнкцией (ИЛИ), часто используется операция «отрицание».

Условные конструкции позволяют выполнять разный код, основываясь на логических проверках.
if — конструкция языка, управляющая порядком инструкций.
Все константы или переменные, определенные внутри блока кода, будут видны только внутри этого блока.
Конструкция switch — это специализированная версия if, созданная для некоторых особых ситуаций.

Алгоритм — это последовательность действий или инструкций, которая приводит нас к какому-то ожидаемому результату.

Каждый такой повтор действий называется итерацией.
Предикат — условие, которое указывается в скобках после while и вычисляется на каждой итерации.

Сокращенный вариант записи: index += 1. Такие сокращения принято называть синтаксическим сахаром, потому что они делают процесс написания кода немного проще и приятнее.

В математике существует понятие нейтральный элемент операции. Операция с таким элементом не изменяет то значение, над которым проводится операция.

Агрегация — накопление результата во время итераций и работа с ним после цикла. 

Цикл while идеален для ситуаций, когда количество итераций неизвестно заранее. Когда количество итераций известно, предпочтительнее использовать цикл for.

Из языка Си в Java перекочевали две операции: инкремент ++ и декремент --, которые очень часто встречаются вместе с циклами.
Используйте инкремент и декремент только там, где нет разницы между префиксным и постфиксным вариантом — отдельно от всего, на отдельной строчке кода.

Пакеты представляют собой механизм для организации классов в логически связанные группы. 
Пакеты позволяют избежать конфликтов имен классов, так как разные пакеты могут иметь классы с одинаковыми именами.
Структура пакетов тесно связана с файловой структурой. Имя пакета всегда соответствует директории проекта, в которых находятся файлы с исходным кодом.
Пакеты могут быть вложенными, то есть один пакет может содержать в себе другие пакеты. Если пакет вложенный, то и директория тоже вложенная.
Чтобы в своем коде использовать классы из другого пакета, их нужно импортировать. Для импорта класса используется ключевое слово import, после которого идет полное имя класса, который мы хотим импортировать.
Импортирование позволяет в коде обращаться к классу просто по его имени, иначе пришлось бы писать полное имя, включая название пакета (fully qualified), что может быть не удобно.
Java позволяет импортировать и использовать статические методы без явного указания класса. ( import static java.lang.Math.*; )

Массив – структура данных, позволяющая работать с набором как с единым целым. 
Массивы представляют собой последовательность элементов одного типа, например чисел или строк. 
Массивы в Java фиксированного размера. Каждый раз когда нужно изменить размер массива, что-то добавить или удалить, придется создавать новый массив куда копируются нужные значения из старого.
Массивы относятся к ссылочным типам данных.
Каждый элемент имеет порядковый номер, называемый индексом. Индексация массива начинается с нуля. 
Созданный, но не инициализированный массив наполняется значениями по умолчанию ( boolean : false, int : 0, double : 0.0, String : null )

Агрегацией называются любые вычисления, которые, как правило, строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее.
Операция прореживания (удаления элементов по определенным условиям) массива обычно называется фильтрацией.

В большинстве задач, использующих цикл, предпочтительнее for-each . Иногда его бывает недостаточно, и требуется ручное управление обходом. В таких случаях можно возвращаться к использованию for. 

Инструкция break производит выход из цикла.
Инструкция continue позволяет пропустить итерацию цикла.

Вложенность массивов никак не ограничивается. Можно создавать массив массивов массивов и так далее.

Копирование строк приводит к серьезному расходу памяти и влияет на производительность. Правильный способ для динамической сборки строк в Java - использование класса StringBuilder.

Множество - набор объектов произвольной природы, рассматривающийся как единое целое.
Все элементы множества должны быть уникальными. 
Понятие «подмножество» означает, что все элементы одного множества также входят в другое множество, называемое надмножеством.
Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.
Объединением множеств называется множество, в которое входят элементы всех данных множеств.
Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе.

В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели.
Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Массив представляется цельным куском памяти, размер которого вычисляется по формуле «количество элементов» * «количество памяти под каждый элемент». 
Размер массива — это фиксированная величина. Все элементы массива имеют один тип и занимают одно и то же количество памяти.

JVM (Java Virtual Machine) - Виртуальная машина отвечает за само выполнение кода. Она работает с байткодом (тем, что находится внутри файлов с расширением .class).
JRE (Java Runtime Environment) - окружение, необходимое для запуска Java-программ. Включает в себя стандартную библиотеку. В нее входят, как базовые пакеты lang, util, так и пакеты для работы с различными форматами, базами данных, пользовательским интерфейсом. JVM тоже часть JRE.
JDK (Java Development Kit) - набор программ для разработки. Именно его мы (или редактор) устанавливаем к себе на компьютер, чтобы заниматься разработкой на Java. Он включает в себя JRE, загрузчик кода java, компилятор javac, архиватор jar, генератор документации javadoc и другие утилиты, нужные во время разработки.

Write once, run anywhere
Кроссплатформенность - способность программы запускаться на разных платформах (архитектура процессора и операционная система) без необходимости компилировать код под эти системы.
JVM выполняет байткод построчно и транслирует его в реальный машинный код, специфичный для той архитектуры, на которой он запускается.

Методы, определенные как static, называют статическими. Статические методы связаны с классами.

На базе классов создаются объекты, из которых потом строится логика работы кода. Класс используется как "шаблон" для создания объектов этого класса (или как говорят "экземпляров класса"). 
Свойства — это любая информация о пользователе: дата рождения, дата создания, имя, наличие доступов и т.п. 
Методы – действия которые может выполнять пользователь.
При таком подходе, программа превращается в набор объектов, которые взаимодействуют друг с другом. 
В программировании такой стиль программирования называется объектно-ориентированным (ООП).

Конструктор класса - специальный метод, определенный внутри класса и имеющий такое же имя как и класс. Конструктор нужен для инициализации объекта.
Java определяет для каждого класса конструктор по умолчанию. Это обычный конструктор, но без параметров.
Перегрузка методов распространяется и на конструктор. 
this — это указатель на текущий объект. Через него мы можем читать и записывать свойства, а также вызывать методы нашего объекта.

В реальном программировании к свойствам не принято обращаться напрямую. Для доступа определяют "геттеры" и "сеттеры". 

При работе с классами нужно придерживаться некоторых соглашений:
- Один файл – один класс. Имя файла и класса совпадают.
- Классы начинаются с заглавной буквы. Методы с прописной за исключением конструктора.
- Сеттеры и Геттеры создаются путем добавления приставки set и get
- Свойства всегда приватные

Строки — это объекты класса java.lang.String
Если у нас нет цели сравнивать ссылки, то для сравнения всегда используем метод equals()

В Java у каждого примитивного типа есть соответствующий "объектный" тип. Последний представлен классом и называется классом-оберткой. (например int - Integer)
Автобоксинг (Autoboxing) - тип преобразуется автоматически в тот момент, когда это нужно.

Интерфейсы позволяют задавать требования к классам, то есть какие методы требуются от класса. 
Задача интерфейса — определить функционал, который затем будет реализован классами. Поэтому интерфейс содержит только сигнатуру методов без их реализации.
Класс реализующий интерфейс должен реализовать все методы интерфейса, причем именно так, как они описаны.
В чем же суть интерфейсов? Если коротко: полиморфизм, а если точнее — полиморфизм подтипов (subtyping). 
Интерфейсы в Java — это настоящие типы данных, поэтому их можно указывать в определениях методов.

К интерфейсам предъявляются такие же требования как и к классам:
- Один файл – один интерфейс. Имя файла и интерфейса совпадают.
- Интерфейсы начинаются с заглавной буквы.

С помощью механизма исключений происходит управление ошибками, которые возникают во время исполнения программы.
Исключение это объект. В этот объект передается сообщение об ошибке плюс в него автоматически записывается информация о том, где это исключение было выброшено.
Блок catch перехватывает исключение, которое было выброшено в блоке try. Само исключение попадает в catch как объект e, который можно при необходимости использовать.
Перехват исключения позволяет программе продолжить работать дальше без остановки.

Проблема конфликта имен актуальна для всех языков программирования и решение у всех примерно одинаковое.  В Java такая система называется пакетами.
Пакеты позволяют группировать похожие классы или даже отдельные проекты. Даже стандартная библиотека Java это не просто набор классов, это набор пакетов.
Помимо разрешения конфликтов имен пакеты выполняют еще одну функцию — контроль доступа. По умолчанию все классы внутри пакета доступны только классам этого же пакета. 
Структура пакетов связана со структурой директорий. Имя пакета всегда соответствует директории, если пакет вложенный, то и директория тоже вложенная.
Статический импорт - Java позволяет импортировать и использовать статические методы и свойства без указания самого класса.

Java – язык, который сильно ориентирован на классы. Практически для любой задачи нужно создавать классы.
Ошибки в Java тоже представлены классами. Для каждого типа ошибки создаются свои классы.
Data-классы - предназначены для хранения или передачи данных куда-то дальше. В Java объекты таких классов называют Data Transfer Object (DTO).
Сервисы - это классы, объекты которых, используются для выполнения однотипных задач вокруг какого-то сервиса или механизма. 
Служебные объекты - классы для взаимодействия с другими программами, такими как базы данных, очереди, кеши и многое другое.
Утилиты - вспомогательные объекты для решения разнообразных задач, например, обработки строк, преобразования Markdown в HTML и тому подобное.

Наследование - это механизм связи между классами, когда один класс, называемый наследуемым (дочерним, подклассом), как бы расширяет другой класс, называемый базовым (родительским, суперклассом).
Наследование никак не влияет на родительский класс, но значительно влияет на класс наследник. Он наследует все, что реализовано в родительском классе. 
Любой класс в Java неявно наследует класс Object. Это делает его суперклассом для всех Java-классов. Любой объект можно представить как объект типа Object.

Прямое сравнение объектов в Java почти всегда (кроме строк) будет возвращать false для разных объектов, даже если их содержимое идентично.
Сравнение объектов в Java реализуется с помощью методов equals() и hashCode(). Основные правила при работе с equals() и hashCode() звучат так:
- Если переопределяется equals(), то должен переопределяться hashCode().
- Одинаковые объекты должны возвращать одинаковый хеш-код.
- Разные объекты могут возвращать одинаковый хеш-код.

В Java разработчики часто сталкиваются с необходимостью написания повторяющегося шаблонного кода (конструкторы, геттеры и сеттеры). Это может приводить к значительному увеличению объема кода.
Lombok – это библиотека, которая позволяет убрать шаблонный код при создании классов. Lombok встраивается в процесс компиляции, во время которой он "наполняет" классы необходимыми методами.

Для получения данных извне и передачи их куда-то дальше в Java используются Data-классы. Обычно это связано с любыми внешними источниками данных, базой данных, HTTP, файлами.
Data-классы это обычные классы без поведения. Из-за этого их стараются делать неизменяемыми, или как говорят иммутабельными (immutable), для избежания случайных ошибок.
Data-классы это настолько большая часть любого приложения на Java, что в язык была внедрена новая конструкция Record (запись). Записи по своей сути Data-классы. 
Несмотря на синтаксическое превосходство, записи обладают рядом недостатков, которые делают их использование в качестве замены обычных классов неудобным. 
Сюда входят:
- Возможность работать только в неизменяемом стиле. Нет сеттеров.
- Только один конструктор со всеми полями.
- Нет наследования (иногда нужно).
- Многие библиотеки и фреймворки до сих пор не совместимы с записями.

В своей работе мы будем встречаться с двумя типами объектов, одни имеют внутреннее состояние, другие - нет.
Чем дальше в программировании, тем больше вы будете замечать, как управление состоянием объектов становится одной из самых сложных частей приложения.
Изменение одного объекта из разных потоков может приводить к непредсказуемому результату, когда данные не соответствуют тому что ожидается.
В ситуациях когда это возможно, лучше предпочитать способ с заполнением через конструктор, тогда объекты будут готовы сразу после создания.
Инварианты - правила, которым должно соответствовать внутреннее состояние объекта. Если эти правила нарушаются, значит в программе есть баги.
На практике объекты часто хранят внутри себя ссылки на другие объекты. Что может легко приводить к нарушению инвариантов без возможности это контролировать.

Состояние может быть не только у объектов, но и у классов. Этот механизм реализуется через статические поля, которые, в отличие от обычных полей, принадлежат не конкретному объекту, а всему классу.
Синтаксически такие поля отличаются от обычных наличием ключевого слова static перед указанием возвращаемого типа. Вызов этих полей происходит напрямую из класса, так же как и статических методов.
Статическое поле принадлежит классу, а не объекту. Это значит что это состояние делят между собой все объекты. Более того, доступ к этому состоянию можно получить из любой части программы в любой момент.
Статические поля достаточно опасны для использования. Так как это, по сути, глобальное состояние (глобальные переменные), то мы можем получить ситуацию, когда разные части приложения используют статические поля для хранения каких-то своих данных. 
Статический блок инициализации -  специальная конструкция внутри класса, которая вызывается при первом его использовании. static { ... }

Списки – это одна из наиболее важных структур данных, которые позволяют организовать и управлять коллекциями объектов в Java-приложениях. В отличие от массивов, коллекции умеют работать с динамическими коллекциями, в которых количество элементов со временем меняется.

Списки в Java представлены набором классов, реализующий интерфейс List, в котором описаны общие методы для работы со списками.
Коллекции – это контейнеры элементов одного типа, поэтому в коллекциях всегда нужно указывать то, что будет внутри них храниться.

Обход списка можно выполнить несколькими способами:
- С помощью цикла for
- С помощью цикла for-each
- С помощью метода forEach()

Технически for-each работает не со списками, а с объектами, реализующими интерфейс Iterable. Этот интерфейс добавлен в List и реализован в ArrayList, поэтому все происходит автоматически.
Итератор - это объект, который позволяет обходить коллекцию элементов. 

Изменение списка во время его обхода не рекомендуется из-за потенциальных ошибок и непредсказуемого поведения. По этой причине, рекомендуется создавать новый список и работать в цикле уже с ним. 

Все операции над списками можно свести к трем основным типам:
- Отображение (map) - это операция, в которой на основе одного списка, формируется другой, с таким же количеством элементов.
- Фильтрация (filter) - это операция, в результате которой на основе одного списка, формируется другой, с элементами, соответствующими условию фильтрации.
- Агрегация -— это операция нахождения какого-то значения, вычисленного на основе анализа всей коллекции.

Множественные операции над списками
- Копирование списков - самый простой способ копировать список — создать новый список с исходным списком, переданным как параметр. itemsCopy = new ArrayList<>(items);
- Сравнение списков - для правильного сравнения понадобится метод equals(). Метод equals() проверяет не только совпадение элементов, но и их порядок. items1.containsAll(items2); - проверка на вхождение
- Слияние списков - Операция выполняется с помощью метода addAll(), который добавляет в коллекцию поэлементно другую коллекцию, переданную как параметр. Этот метод меняет исходную коллекцию:
- Объединение списков - подразумевает то, что если элементы присутствуют в обоих списках, в результирующий список они попадут лишь в одном экземпляре. CollectionUtils.union()
- Пересечение списков - поиск общих элементов, то есть тех, которые есть и в первом, и во втором списке. Пересечение выполняется с помощью метода retainAll(). Этот метод меняет исходную коллекцию.
- Разность списков - коллекция, состоящая из элементов первой коллекции, которых нет во второй. CollectionUtils.subtract().

- Сортировка списков - самый простой способ отсортировать коллекцию по возрастанию — это воспользоваться методом Collections.sort().
Эта сортировка работает с примитивными типами и сортирует значения с учетом естественного порядка по возрастанию (от меньшего числа к большему). 
В случае строк это сортировка в лексиграфическом порядке, который в большинстве случаев совпадает с алфавитным порядком.
Для сортировки объектов нужно явно указывать то как выполнять сортировку.

Comparator - объект, который определяет то, как выполняется сравнение элементов. 

ArrayList - использует массив, что позволяет работать быстро в случае необходимости обращаться к произвольным элементам по индексу, но медленно, если нам нужно добавить или удалить элемент списка.
LinkedList - эта реализация списка основана на структуре данных называемой двунаправленный список. В этой структуре элементы связаны друг с другом через ссылку на следующий и предыдущий элемент.

Maps предоставляют мощный и гибкий способ хранения и управления данными в виде пар ключ-значение. 
В стандартную библиотеку входит интерфейс Map, который описывает основные методы для работы коллекции. 
Там же находятся конкретные реализации этого интерфейса, которые отличаются производительностью и потребляемыми ресурсами.
Map.of() создает неизменяемую коллекцию, то есть его элементы можно использовать, но изменять саму коллекцию нельзя. 
Хеш-код это число, которое формируется для каждого ключа добавленного в HashMap. Оно используется для того, чтобы определить место в хеш-таблице для данной пары ключ-значение.

Всего есть два основных подхода к этим обходам:
- С помощью метода forEach(). 
- С помощью преобразования HashMap в коллекцию, которая работает с for-each. Этот подход включает в себя три варианта: обход пар ключ-значения (entrySet()), обход значений values() и обход ключей keySet().

Независимо от способа обхода, важно учитывать то, что HashMap не является последовательной структурой как ArrayList. Порядок добавления элементов не влияет на их порядок обхода. 

Лямбда-функции или, как их еще называют, анонимные функции.
Лямбда-функция записывается так: () -> {}. То, что в скобках – это параметры. То, что в фигурных скобках – это тело функции. Знак -> отделяет параметры от тела.
Мы можем внутри тела лямбда-функции использовать данные взятые из внешнего контекста. Но есть ограничение. Лямбда-функции не могут изменять значение переменных, с которыми идет работа.
Лямбда-функции позволяют отделить алгоритм сортировки от логики сравнения элементов.
Метод compute() обновляет значение ключа в Map, на основе логики, заданной внутри лямбда-функции.
Метод computeIfAbsent() отличается от compute(), тем, что лямбда вызывается только в том случае, если ключа в коллекции до этого не было.
Метод computeIfPresent() отличается от compute() тем, что лямбда вызывается только в том случае, если ключ уже был добавлен в коллекцию. 
В Java все реализуется через классы, даже если снаружи так не кажется. Лямбда-функции — не исключение. 
Функциональный интерфейс — это интерфейс с единственным абстрактным методом. Он "под капотом" используется как тип для соответствующих ему лямбда-функций. 
Лямбда-функция — это объект, который реализует функциональный интерфейс, где методом является определение лямбда-функции.
Ссылка на метод (Method Reference) – это сокращенная форма лямбда выражения для вызова методов. То есть это синтаксический сахар, который делает код короче и проще для чтения.
Общий синтаксис ссылки на метод выглядит так: Name::methodName. Где Name может быть как объектом так и классом, в зависимости от того, ссылку на что мы хотим получить и как это будет использовано потом. 

objectName::methodName // (v) -> objectName.methodName(v)
ClassName::staticMethodName // (v) -> ClassName.staticMethodName(v)
ClassName::methodName // (v) -> v.methodName()

Generics – это механизм языка программирования Java, который позволяет программистам убрать дублирование кода при реализации общего поведения для разных типов данных. 
Дженерики, с одной стороны убирают дублирование кода, с другой обеспечивают типобезопасность. Концепция дженериков основана на понятии "параметр типа". То есть у типа (класса или интерфейса) появляется параметр, который тоже является типом. Этот параметр определяет то, с каким типом будет работать дженерик для конкретной ситуации.
Программирование с использованием дженериков часто называют обобщенным программированием, а сами дженерики параметризуемыми типами. 

Существует несколько видов полиморфизмов:
- Ad-hoc полиморфизм в Java – это просто перегрузка методов.
- Полиморфизм подтипов (subtyping).
- Параметрический полиморфизм - позволяет одному куску кода работать идентично для разных типов данных. То есть дженерики – это реализация параметрического полиморфизма для Java.

Программирование с использованием дженериков (или параметрического полиморфизма) называется обобщенным программированием (generic programming). Классы и интерфейсы называются обобщенными типами, а методы обобщенными методами. 
Дженерики не создают нагрузку в рантайме. Компилятор генерирует нужные классы и интерфейсы для конкретных типов, что немного замедляет время компиляции, но на этом все.

У обобщенных методов могут быть свои параметры типов, которых нет в классе.
В отличие от обычных методов, статические методы не связаны с объектами классов, поэтому обобщенные статические методы существуют сами по себе, независимо от того, является ли класс дженериком или нет.

Wildcard с ограничениями extends и super делает Generics в Java более гибкими и безопасными.
Используя extends, мы можем работать с коллекциями, которые производят данные.
C помощью super мы можем работать с коллекциями, которые потребляют данные.
Принцип PECS (Producer Extends, Consumer Super) помогает запомнить, когда и какой тип ограничения использовать.

Стримы Java - это абстракция, которая позволяет обрабатывать последовательности данных, например, коллекции в декларативном стиле.
Декларативное программирование - это парадигма программирования, которая фокусируется на том, что компьютер должен сделать, а не том как это сделать.
Стримы представляют собой последовательность элементов с набором методов позволяющих преобразовывать эти элементы и выполнять над ними разнообразные вычисления. 
Благодаря разделению и возможности комбинации, стримы позволяют решать большинство задач преобразования коллекций без необходимости возвращаться к циклам.

Отображение (map) - это базовая операция в стримах. Она берет исходный список и формирует на его основе другой, преобразуя каждый элемент по указанным правилам.
Метод map() принимает как параметр лямбда-функцию, которая должна вернуть значение, вычисленное на базе переданного значения из исходной коллекции. Результатом может быть все что угодно.

Фильтрация (filter) - позволяет отсеивать элементы из потока данных на основе заданных критериев. 
В отличие от операции отображения, фильтрация не выполняет преобразования элемента, она лишь вычисляет необходимость добавить это значение в результирующую коллекцию. 
Лямбда-функция в этом случае называется предикатом, так как ее задача вернуть булево значение. Если значение нужно добавить в новую коллекцию, тогда возвращается true, иначе false.

Свертка (reduce) - это терминальная операция, которая обрабатывает элементы стрима и возвращает одно значение. 
У свертки есть начальное значение. Следующее значение в свертке базируется на результате, который был получен на предыдущей итерации.
reduce() принимает на вход два параметра, первый это начальное значение, второй лямбда выполняющая операцию свертки. В эту лямбду приходит два параметра: результат предыдущего вычисления и текущий элемент.
Накапливаемый результат в процессе вычисления принято называть аккумулятором, так как он аккумулирует значение. 
Комбайнер - третий параметр в reduce(), который обычно используется для параллельного запуска вычисления. Комбайнер помогает компилятору увидеть тип аккумулятора.

Разделение на независимые этапы позволяет разбить сложную операцию таким образом, что на каждом этапе понадобится думать только о небольшой операции, которую легко проанализировать.
Стримы в Java ленивые. Их реальный вызов не начинается до тех пор, пока эти данные не понадобятся. При этом внутри все реализовано таким образом, что выполняется один проход, во время которого данные пропускаются через всю цепочку функций.

Optional- это тип обертка, который хранит реальное значение внутри себя предоставляя к нему доступ через различные методы. 

- Приоритет читаемости и ясности. Сложные стримы разбивайте на более мелкие и понятные шаги. 
- Избегайте побочных эффектов. Операции со стримами должны избегать изменения исходных данных.
- Читаемость важнее производительности. Используйте стримы для улучшения читаемости кода. 
- Используйте ссылки на методы. Для упрощения кода используйте ссылки на методы. 
- Ограничьте область применения потоков. Используйте стримы для сложных операций с коллекциями. 
- Будьте осторожны с терминальными операциями. После терминальной операции стрим нельзя использовать повторно. 
- Используйте невмешательные операции. Не изменяйте источник стрима во время его обработки.

Автоматизированное тестирование — неотъемлемая часть процесса программирования в профессиональной среде. 
Тесты — единственный надёжный способ убедиться в работоспособности кода. Они не избавляют от багов, но позволяют держать их количество на приемлемом уровне. 
Среди разных видов автоматизированных тестов, программисты, в первую очередь, отвечают за функциональные тесты. Эти тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы.

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:
- Модульные - они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, но они не способны помочь проверить, что модули работают вместе.
- Интеграционные - у программистов на такие тесты должно быть направлено основное внимание. Их всё ещё достаточно просто писать , и они охватывают гораздо большую часть системы.
- Системные - наиболее сложные и максимально эффективные . Они представляют из себя полную имитацию работы всей системы целиком. 

Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.
Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически неосуществимо.

При написании тестов нужно ориентироваться на разнообразие входных данных. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:
- Работа с пустой строкой
- Обработка null
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию.
Комбинация всех возможных вариантов поведения метода называется цикломатической сложностью. Это число показывает все возможные пути кода внутри метода. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

Утверждения (assert) — ключевая часть тестов. Именно они проверяют работу кода.
Java поддерживает ключевое слово assert, которое предназначено для проверки утверждений. По умолчанию он отключен. При запуске программы нужно указать аргумент командной строки -enableassertions (-ea).
Встроенный в Java механизм проверки утверждений assert обладает рядом недостатков:
- Вы не можете быть уверены что он сработает в любой ситуации. Если запустить программу без аргумента -enableassertions (-ea), то проверки будут игнорироваться. 
- Сами проверки сильно ограничены. 
- Результат проверки неинформативен.

Матчеры стали популярны в тестовых фреймворках после появления подхода BDD (Behaviour Driven Development, разработка через поведение). Технически, такой подход стремится сделать тесты похожими на словесное описание выполняемой задачи. 

Первый тест всегда должен проверять позитивный сценарий — тот, в котором задействована основная функциональность тестируемого компонента.
Следующим тестом будет тест на дополнительную функциональность.
Ну, и последнее, что можно протестировать — пограничные случаи.

AssertJ - отличная библиотека для тестов, но это именно библиотека. Она предоставляет большое количество классов и методов. Однако точкой входа в вашу программу и тесты останется всё тот же метод main().
JUnit - это уже фреймворк. Он обладает своей собственной точкой входа , что делает его фактически второй программой, которая живёт отдельно от вашего основного кода.
JUnit устроен так, что создаёт новый экземпляр класса для каждого теста (метода, помеченного аннотацией @Test). Порядок запуска тестовых методов не гарантируется.

Тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.
Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста. От этого надо избавляться и никогда так не писать.
Задача @BeforeEach — готовить данные и среду для тестирования, а задача @Test — вызывать код, который тестируется, и проводить проверки.
Слишком сильная детализация. Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка.
Ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки.

Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). Покрытие анализируется тестовыми фреймворками, которые считают отношения строчек, задействованных в тестах, ко всем строчкам исходного кода. В JUnit, к сожалению, нет встроенного метода, который измеряет покрытие кода тестами.
Однако, покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях. Логические ошибки в коде невозможно отследить только покрытием. 
Какое покрытие считается допустимым? Большинство разработчиков сходится во мнении, что 80% — это достаточно хорошее покрытие. На этом можно и остановиться.

В мире разработки подход, при котором тесты пишутся до кода, называется Test-Driven Development (TDD) - Разработка через тестирование.

Данные, которые нужны во время запуска тестов, называются фикстурами. Это не обязательно текстовые данные. Фикстурами могут быть картинки, JSON и XML-файлы, записи в базе данных и многое другое.
Обычно фикстуры хранятся в отдельных файлах в своей директории в ресурсах. Например src/test/resources/fixtures.

Паттерны - это принципы организации кода, для решения каких-то распространенных задач в программировании.

Билдер (Builder) - это шаблон проектирования, который используется там, где есть необходимость постепенного создания объекта, таким образом, чтобы гарантировалась его целостность.

Синглетон (Singleton) - это широкоизвестный шаблон проектирования используемый в том случае, когда нужно ограничить класс созданием ровно одного объекта.
Синглотон называют не паттерном, а антипаттерном. Поэтому программисты рекомендуют отказаться от синглетона в пользу инъекции зависимостей.

Реализация связи один ко многим (one to many, o2m) включает три элемента:
- Поле с коллекцией на одном конце
- Поле с родительским объектом на другом конце
- Логика добавления и удаления урока из курса

Помимо связи один-ко-многим, очень распространена связь многие-ко-многим. 
Такую связь реализуют с помощью введения третьей сущности, которая может и, обычно, содержит какие-то дополнительные данные появляющиеся только во время создания связи.

Для структуры классов приложения их связей был придуман способ визуального представления, называемый диаграммой классов - UML (Unified Modeling Language).

Java – объектно-ориентированный язык программирования. Код в Java представляет собой набор классов и объектов, которые взаимодействуют друг с другом.

Класс - шаблон для объекта. Каждый объект является объектом какого-то класса.

Интерфейсы в Java представляют собой абстрактные типы, которые определяют набор методов, но не содержат их реализаций. 
Они позволяют создавать контракты для классов, которые должны реализовать указанные методы, обеспечивая тем самым полиморфизм и возможность работы с различными классами через общий интерфейс.
Один класс в Java может реализовывать несколько интерфейсов одновременно.
В Java интерфейсы могут расширять другие интерфейсы, что позволяет создавать иерархии интерфейсов. Когда один интерфейс расширяет другой, он наследует все методы родительского интерфейса.
В Java интерфейсы могут содержать статические переменные и методы, которые можно вызывать без создания экземпляра класса, реализующего этот интерфейс.
Статические переменные интерфейса автоматически являются константами. 
Java позволяют добавлять реализацию метода непосредственно в интерфейс, используя ключевое слово default. Дефолтные методы обеспечивают обратную совместимость, позволяя существующим классам продолжать работать, даже если интерфейс был обновлён.

В Java наследование позволяет создавать новые классы на основе существующих, что упрощает процесс разработки и повторного использования кода. 
В Java абстрактные классы используются для определения общих свойств и методов, которые могут быть унаследованы другими классами.
Ключевое слово final в Java используется для обозначения неизменяемости. Оно может применяться к переменным, методам и классам.

В Java модификаторы доступа используются для определения уровня доступа к классам, методам и полям, что позволяет контролировать, кто может использовать или изменять эти элементы.
Существует четыре основных модификатора доступа: 
- private - доступно только внутри класса
- package visible (default) - доступно только из классов, лежащих в одном пакете с исходным классом.
- protected — доступно внутри класса и внутри классов-наследников.
- public — доступно из любых других классов.

В Java все классы неявно наследуются от класса Object, который является корнем иерархии классов. Это означает, что каждый класс в Java наследует методы, определенные в Object.

Исключение в программировании - это событие, которое возникает во время выполнения программы и нарушает нормальный поток ее работы.
В Java, обработка исключений может быть осуществлена двумя основными способами: либо обработать исключение непосредственно в месте его возникновения, либо пробросить его дальше, чтобы оно было обработано на более высоком уровне.
Конструкция try with resources - это особый вид блоков try, который позволяет автоматически закрывать ресурсы, такие как файлы, сокеты или соединения с базой данных, после их использования. (Closeable)
В Java, ключевое слово throws используется для указания того, что метод может генерировать определенное исключение, которое не будет обработано внутри метода, а будет передано вызывающему коду.
Для генерации исключения используется ключевое слово throw. ( throw new RuntimeException() )
В Java, реализация собственных исключений позволяет разработчикам создавать пользовательские исключения, которые могут быть использованы для обработки конкретных ошибок или ситуаций в программе.

Рефлексия — это механизм, который позволяет программе получать информацию о своей собственной структуре и поведении во время выполнения, включая классы, методы, поля и другие элементы. 
Это позволяет программе динамически создавать и манипулировать объектами, вызывать методы и получать доступ к полям, не зная заранее их имен или типов.




Числа
  - Натуральные — это целые числа от 1 и больше
  - Рациональные — это числа с точкой, например, 0.5  ( операции с плавающими числами неточны, но эту точность можно регулировать. )


Диспетчеризация динамических методов представляет собой механизм, с помощью которого вызов переопределенного
метода распознается во время выполнения, а не на этапе компиляции. Динамическая диспетчеризация методов важна, потому что именно так в Java обеспечивается полиморфизм во время выполнения.

Object представляет собой супер-класс для всех остальных классов. Это означает, что ссылочная переменная типа Object может ссылаться на объект любого другого класса.

Все классы в Java принадлежат какому-то пакету. Если оператор package от-сутствует, тогда используется стандартный пакет.

Исключение - это ошибка, которая возникает во время выполнения.
Системные исключения автоматически генерируются исполняющей средой Java. Для ручной генерации исключения используйте ключевое слово throw.

Поток данных (stream) — это абстракция, которая либо производит, либо потребляет информацию. Поток связан с физическим устройством посредством системы ввода-вывода Java.

Процесс инкапсуляции значения внутри объекта называется упаковкой.
Процесс извлечения значения из оболочки типа называется распаковкой.

Автоупаковка — это процесс, с помощью которого примитивный тип автоматически инкапсулируется (упаковывается) в эквивалентную ему оболочку типа всякий раз, когда требуется объект такого типа.
Автораспаковка - это процесс, при котором значение упакованного объекта автоматически извлекается (распаковывается) из оболочки типа, когда значение необходимо.

оператор import static можно применять для импортирования статических элементов классов и интерфейсов.

Аннотации, не имеющие параметров, называются маркерными аннотациями. Их единственная цель — пометить элемент каким-то атрибутом.

instanceof — это инструмент, с помощью которого программа может выяснять во время выполнения, является ли объект экземпляром указанного типа.

Класс, интерфейс или метод, оперирующий на параметризованном типе, называется обобщенным.

Лямбда-выражение представляет собой анонимный (т.е. безымянный) метод. Однако такой метод не выполняется сам по себе. Взамен он используется для реализации метода, определенного функциональным интерфейсом.
Функциональный интерфейс — это интерфейс, который содержит один и только один абстрактный метод, обычно устанавливающий предполагаемое назначение интерфейса.
функциональный интерфейс иногда называют типом SAM, где SAM означает Single Abstract Method — единственный абстрактный метод.

Модули предоставляют способ описания отношений и зависимостей кода, из которого состоит приложение. Модули также позволяют контролировать то, какие части модуля доступны другим модулям, а какие нет.

Служба в Java представляет собой программную единицу, функциональность которой определяется интерфейсом или абстрактным классом. Служба задает в общем виде некоторую форму программной деятельности. 
Конкретная реализация службы предоставляется поставщиком службы. Другими словами, служба определяет форму какого-то действия, а поставщик службы предоставляет это действие.

метаданные — это данные о данных.
Аннотации — это механизм со своим синтаксисом, который позволяет добавлять метаданные в код.
Сами по себе аннотации на код никак не влияют, в этом смысле они похожи на комментарии. Все действия происходят в коде, который ищет аннотации и на их основе меняет поведение.

Приведенная кодовая последовательность создает объект SwingDemo в потоке диспетчеризации событий, а не в главном потоке приложения.

Событие в Java представляет собой объект, описывающий изменение состояния в источнике событий. Событие может быть сгенерировано в результате взаимодействия пользователя с элементом в графическом пользовательском интерфейсе или под управлением программы.
Источник событий — это объект, который генерирует событие. Когда источник генерирует событие, он отправляет его всем зарегистрированным прослушивателям.
Прослушиватель — это объект, который уведомляется, когда происходит событие.

Анонимные внутренние классы — это внутренние классы, не имеющие имени. Взамен экземпляр такого класса просто генерируется “на лету” по мере необходимости.

Байт-код — это оптимизированный набор инструкций, который выполняется виртуальной машиной Java. Байт-код помогает Java обеспечивать как переносимость, так и безопасность.
Переменная — это именованная ячейка памяти.
Диапазон и поведение примитивных типов в Java строго определяются длятого, чтобы обеспечить переносимость между платформами.
Когда операция инкремента предшествует своему операнду, тогда инкрементирование будет выполняться до получения значения операнда с целью использования в остальной части выражения. 
Если операция инкремента находится после своего операнда, то значение операнда будет получено перед инкрементированием.
Класс — это логическая абстракция, описывающая форму и поведение объекта. 
Объект — это физический экземпляр класса.
Операция new выделяет память для объекта и инициализирует его с использованием конструктора класса.
Сборка мусора — это механизм, который удаляет неиспользуемые объекты, чтобы память, которую они занимали, можно было задействовать повторно.
Абстрактный класс — это такой класс, который содержит хотя бы один абстрактный метод.
Пространство имен — это область объявлений. Разделяя пространство имен, можно предотвратить конфликты имен.
Член с защищенным доступом может использоваться в своем пакете и подклассами в других пакетах. 
Член со стандартным доступом может использоваться только внутри своего пакета.
На вершине иерархии исключений находится класс Throwable.
Исключение может быть сгенерировано машиной JVM, по причине ошибки в вашей программе или явно с помощью оператора throw.
Многопоточность позволяет использовать время простоя, которое присутствует почти во всех программах. Когда один поток не может работать, то способен функционировать другой.
Упаковка — это процесс сохранения значения примитивного типа внутри объекта оболочки типа. 
Распаковка — это процесс извлечения значения примитивного типа из объекта оболочки типа. 
Автоупаковка автоматически упаковывает значение примитивного типа без необходимости в явном создании объекта. 
Автоматическая распаковка автоматически извлекает значение примитивного типа из объекта оболочки типа без необходимости в явном вызове метода.
Статическое импортирование помещает в текущее пространство имен статические члены класса или интерфейса.
Маркерная аннотация — это аннотация, которая не принимает аргументов.
Функциональный интерфейс — это интерфейс, который содержит один и только один абстрактный метод.
Лямбда-выражение предоставляет реализацию абстрактного метода, определенного в функциональном интерфейсе.
Ссылка на метод — это способ обращения к методу, не выполняя его.
Утилита javadoc принимает в качестве входных данных исходный файл программы на Java и выводит несколько файлов HTML, содержащих документацию по программе.


