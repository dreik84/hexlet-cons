 Инструкции (Statements):

Инструкция — это команда для компьютера. Код на Java — это набор инструкций, которые, обычно, отделяются друг от друга символом ;

Инструкция — это единица исполнения. Программа, которая запускает код на Java, выполняет инструкции строго по очереди. 

Инструкции ― каркас программы, к ним относят условные конструкции, циклы и классы. Например, if, if-else, while, for. Они задают маршрут, по которому компьютер будет обрабатывать код, но сами никаких действий не производят и не возвращают результат.

Выражения:

Выражение — нечто возвращающее результат, который можно использовать.
Выражения в Java состоят из операндов и операторов. 
Любая строка — выражение. Причем и конкатенация строк — тоже выражение. Когда программа видит выражение, она вычисляет его и возвращает результат.

Операторы:

Операторы — это команды, которые указывают компьютеру, какие действия нужно совершить над операндами. 

Оператор — просто символ, который выполняет операцию.  + — это оператор, а числа 8 и 2 — это операнды.
Операции, которые требуют наличия двух операндов, называются бинарными. Бывают еще: Унарные — с одним операндом и Тернарные — с тремя операндами.
Бинарная операция считается коммутативной, если вы получаете тот же самый результат, поменяв местами операнды. 

Приоритеты операторов - В языке Java последовательность выполнения операций выстроена так, чтобы соблюсти правила арифметики. ???

\n — это пример экранирующей последовательности (escape sequence). Их еще называют управляющими конструкциями.
Операция соединения строк в программировании называется конкатенацией.

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить в начале. Имена переменных регистрозависимы.
Java — статически типизированный язык. Это значит, что тип переменной задается при определении и больше не меняется.
Java — язык со строгой типизацией. Проще говоря, любой переменной необходимо присваивать тип данных.
Любая переменная может быть частью любого выражения. В момент вычисления вместо имени переменной подставляется ее значение.

Именование переменных:
kebab-case — составные части переменной разделяются дефисом (my-super-var)
snake_case — для разделения используется подчеркивание (my_super_var)
CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
lowerCamelCase — каждое слово в переменной пишется с заглавной буквы, кроме первого (mySuperVar)

В Java используется CamelCase и его вариация lowerCamelCase, при котором первая буква первого слова — строчная.

Магические числа (magic numbers) — числа, происхождение которых невозможно понять без глубокого знания происходящего внутри участка кода.

Типы определяют две вещи:
- Допустимые значения.
- Набор допустимых операций.

var – специальное ключевое слово, которое включает механизм вывода типов. Вывод типов автоматически определяет тип присваиваемого значения и связывает его с переменной. 

Глобально, типы данных в Java делятся на две большие группы:
Примитивные — предопределены в Java. Примитивные данные всегда имеют значение, даже если они определяются без инициализации. Примитивные данные сравниваются по значению.
Ссылочные — создаются самим программистом, за исключением String и Array. У ссылочных в качестве значения по умолчанию используется null. Ссылочные сравниваются по ссылкам. 

Всего в Java восемь примитивных типов данных:

byte
short
int
long
float
double
boolean
char

Особняком в Java стоит значение null. В Java оно не является типом. Это просто конкретное значение со специальным смыслом и логикой работы.
Любой ссылочный тип данных может принимать значение null. А вот примитивные типы и null не совместимы. Примитивное значение всегда должно быть определено.

Значение по умолчанию

Явное преобразование типов (cast)
Неявное преобразование типов - автоматическое преобразование типов без явного указания программистом.

Функции — одна из ключевых конструкций в программировании. Все функции Java создаются только внутри классов, которые мы пока не разбирали. А функции, которые определены внутри классов, принято называть методами.
Методы — это действия, которые нужно выполнить над данными, к которым они применяются.
В вызовы методов можно передавать параметры.

Синтаксические ошибки - нарушают правила синтаксиса языка. Эти ошибки обнаруживаются на этапе компиляции, до реального запуска.
Ошибки типов - процесс проверки соответствия типов выполняется на этапе компиляции до запуска программы на выполнение.
Ошибки выполнения - возникают в процессе работы. Такие ошибки базируются на механизме исключения (exceptions).
Логические ошибки - ошибки, которые не приводят к остановке программы. То есть программа работает, но ее результат не соответствует ожидаемому.
Ошибки линтера - код на соответствие стандартам кодирования (checkstyle).Соблюдение данных правил не влияет на результат, но помогает писать код понятнее и проще для восприятия.

Строки в Java неизменяемы. Не существует способа и методов, способных изменить саму строку. Любой метод строки может только вернуть новую строку.

Детерминированность
Метод называется детерминированным тогда, когда для одних и тех же входных параметров он возвращает один и тот же результат. 

Побочным эффектом называют действия, которые соприкасаются с внешним окружением. К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран, печать на принтере и так далее.

return – это особая инструкция. Она берет выражение справа и отдает его наружу тому коду, который вызвал метод. Как только Java натыкается на return, выполнение метода на этом завершается.

Параметры методов в Java всегда обязательны. 
В отличие от других языков, в Java нет возможности задать значение параметров по умолчанию, но ее можно имитировать с помощью перегрузки методов.
Java позволяет создать несколько методов с одинаковым именем. У таких одинаковых методов должно выполняться одно из условий:
	- Разные типы входных параметров
	- Разное количество параметров
	- Все перечисленное выше одновременно

Перегрузка методов может приводить к дублированию кода. Для снижения дублирования достаточно сделать два шага:
	- Сначала определить общий метод, который принимает больше всего параметров
	- Затем вызывать его из тех методов, где есть значения по умолчанию

Как и во многих других языках, в Java все данные делятся на два больших типа:
	- Примитивные данные сравниваются по значению, независимо от адресов
	- Ссылочные данные сравниваются по адресам

Область математики, в которой изучаются логические операторы, называется булевой алгеброй.
Наряду с конъюнкцией (И) и дизъюнкцией (ИЛИ), часто используется операция «отрицание».

Условные конструкции позволяют выполнять разный код, основываясь на логических проверках.
if — конструкция языка, управляющая порядком инструкций.
Все константы или переменные, определенные внутри блока кода, будут видны только внутри этого блока.
Конструкция switch — это специализированная версия if, созданная для некоторых особых ситуаций.

Алгоритм — это последовательность действий или инструкций, которая приводит нас к какому-то ожидаемому результату.

Каждый такой повтор действий называется итерацией.
Предикат — условие, которое указывается в скобках после while и вычисляется на каждой итерации.

Сокращенный вариант записи: index += 1. Такие сокращения принято называть синтаксическим сахаром, потому что они делают процесс написания кода немного проще и приятнее.

В математике существует понятие нейтральный элемент операции. Операция с таким элементом не изменяет то значение, над которым проводится операция.

Агрегация — накопление результата во время итераций и работа с ним после цикла. 

Цикл while идеален для ситуаций, когда количество итераций неизвестно заранее. Когда количество итераций известно, предпочтительнее использовать цикл for.

Из языка Си в Java перекочевали две операции: инкремент ++ и декремент --, которые очень часто встречаются вместе с циклами.
Используйте инкремент и декремент только там, где нет разницы между префиксным и постфиксным вариантом — отдельно от всего, на отдельной строчке кода.

Пакеты представляют собой механизм для организации классов в логически связанные группы. 
Пакеты позволяют избежать конфликтов имен классов, так как разные пакеты могут иметь классы с одинаковыми именами.
Структура пакетов тесно связана с файловой структурой. Имя пакета всегда соответствует директории проекта, в которых находятся файлы с исходным кодом.
Пакеты могут быть вложенными, то есть один пакет может содержать в себе другие пакеты. Если пакет вложенный, то и директория тоже вложенная.
Чтобы в своем коде использовать классы из другого пакета, их нужно импортировать. Для импорта класса используется ключевое слово import, после которого идет полное имя класса, который мы хотим импортировать.
Импортирование позволяет в коде обращаться к классу просто по его имени, иначе пришлось бы писать полное имя, включая название пакета (fully qualified), что может быть не удобно.
Java позволяет импортировать и использовать статические методы без явного указания класса. ( import static java.lang.Math.*; )

Массив – структура данных, позволяющая работать с набором как с единым целым. 
Массивы представляют собой последовательность элементов одного типа, например чисел или строк. 
Массивы в Java фиксированного размера. Каждый раз когда нужно изменить размер массива, что-то добавить или удалить, придется создавать новый массив куда копируются нужные значения из старого.
Массивы относятся к ссылочным типам данных.
Каждый элемент имеет порядковый номер, называемый индексом. Индексация массива начинается с нуля. 
Созданный, но не инициализированный массив наполняется значениями по умолчанию ( boolean : false, int : 0, double : 0.0, String : null )

Агрегацией называются любые вычисления, которые, как правило, строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее.
Операция прореживания (удаления элементов по определенным условиям) массива обычно называется фильтрацией.

В большинстве задач, использующих цикл, предпочтительнее for-each . Иногда его бывает недостаточно, и требуется ручное управление обходом. В таких случаях можно возвращаться к использованию for. 

Инструкция break производит выход из цикла.
Инструкция continue позволяет пропустить итерацию цикла.

Вложенность массивов никак не ограничивается. Можно создавать массив массивов массивов и так далее.

Копирование строк приводит к серьезному расходу памяти и влияет на производительность. Правильный способ для динамической сборки строк в Java - использование класса StringBuilder.

Множество - набор объектов произвольной природы, рассматривающийся как единое целое.
Все элементы множества должны быть уникальными. 
Понятие «подмножество» означает, что все элементы одного множества также входят в другое множество, называемое надмножеством.
Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.
Объединением множеств называется множество, в которое входят элементы всех данных множеств.
Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе.

В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели.
Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Массив представляется цельным куском памяти, размер которого вычисляется по формуле «количество элементов» * «количество памяти под каждый элемент». 
Размер массива — это фиксированная величина. Все элементы массива имеют один тип и занимают одно и то же количество памяти.

JVM (Java Virtual Machine) - Виртуальная машина отвечает за само выполнение кода. Она работает с байткодом (тем, что находится внутри файлов с расширением .class).
JRE (Java Runtime Environment) - окружение, необходимое для запуска Java-программ. Включает в себя стандартную библиотеку. В нее входят, как базовые пакеты lang, util, так и пакеты для работы с различными форматами, базами данных, пользовательским интерфейсом. JVM тоже часть JRE.
JDK (Java Development Kit) - набор программ для разработки. Именно его мы (или редактор) устанавливаем к себе на компьютер, чтобы заниматься разработкой на Java. Он включает в себя JRE, загрузчик кода java, компилятор javac, архиватор jar, генератор документации javadoc и другие утилиты, нужные во время разработки.

Write once, run anywhere
Кроссплатформенность - способность программы запускаться на разных платформах (архитектура процессора и операционная система) без необходимости компилировать код под эти системы.
JVM выполняет байткод построчно и транслирует его в реальный машинный код, специфичный для той архитектуры, на которой он запускается.

Методы, определенные как static, называют статическими. Статические методы связаны с классами.

На базе классов создаются объекты, из которых потом строится логика работы кода. Класс используется как "шаблон" для создания объектов этого класса (или как говорят "экземпляров класса"). 
Свойства — это любая информация о пользователе: дата рождения, дата создания, имя, наличие доступов и т.п. 
Методы – действия которые может выполнять пользователь.
При таком подходе, программа превращается в набор объектов, которые взаимодействуют друг с другом. 
В программировании такой стиль программирования называется объектно-ориентированным (ООП).

Конструктор класса - специальный метод, определенный внутри класса и имеющий такое же имя как и класс. Конструктор нужен для инициализации объекта.
Java определяет для каждого класса конструктор по умолчанию. Это обычный конструктор, но без параметров.
Перегрузка методов распространяется и на конструктор. 
this — это указатель на текущий объект. Через него мы можем читать и записывать свойства, а также вызывать методы нашего объекта.

В реальном программировании к свойствам не принято обращаться напрямую. Для доступа определяют "геттеры" и "сеттеры". 

При работе с классами нужно придерживаться некоторых соглашений:
- Один файл – один класс. Имя файла и класса совпадают.
- Классы начинаются с заглавной буквы. Методы с прописной за исключением конструктора.
- Сеттеры и Геттеры создаются путем добавления приставки set и get
- Свойства всегда приватные

Строки — это объекты класса java.lang.String
Если у нас нет цели сравнивать ссылки, то для сравнения всегда используем метод equals()

В Java у каждого примитивного типа есть соответствующий "объектный" тип. Последний представлен классом и называется классом-оберткой. (например int - Integer)
Автобоксинг (Autoboxing) - тип преобразуется автоматически в тот момент, когда это нужно.

Интерфейсы позволяют задавать требования к классам, то есть какие методы требуются от класса. 
Задача интерфейса — определить функционал, который затем будет реализован классами. Поэтому интерфейс содержит только сигнатуру методов без их реализации.
Класс реализующий интерфейс должен реализовать все методы интерфейса, причем именно так, как они описаны.
В чем же суть интерфейсов? Если коротко: полиморфизм, а если точнее — полиморфизм подтипов (subtyping). 
Интерфейсы в Java — это настоящие типы данных, поэтому их можно указывать в определениях методов.

К интерфейсам предъявляются такие же требования как и к классам:
- Один файл – один интерфейс. Имя файла и интерфейса совпадают.
- Интерфейсы начинаются с заглавной буквы.

С помощью механизма исключений происходит управление ошибками, которые возникают во время исполнения программы.
Исключение это объект. В этот объект передается сообщение об ошибке плюс в него автоматически записывается информация о том, где это исключение было выброшено.
Блок catch перехватывает исключение, которое было выброшено в блоке try. Само исключение попадает в catch как объект e, который можно при необходимости использовать.
Перехват исключения позволяет программе продолжить работать дальше без остановки.

Проблема конфликта имен актуальна для всех языков программирования и решение у всех примерно одинаковое.  В Java такая система называется пакетами.
Пакеты позволяют группировать похожие классы или даже отдельные проекты. Даже стандартная библиотека Java это не просто набор классов, это набор пакетов.
Помимо разрешения конфликтов имен пакеты выполняют еще одну функцию — контроль доступа. По умолчанию все классы внутри пакета доступны только классам этого же пакета. 
Структура пакетов связана со структурой директорий. Имя пакета всегда соответствует директории, если пакет вложенный, то и директория тоже вложенная.
Статический импорт - Java позволяет импортировать и использовать статические методы и свойства без указания самого класса.

Java – язык, который сильно ориентирован на классы. Практически для любой задачи нужно создавать классы.
Ошибки в Java тоже представлены классами. Для каждого типа ошибки создаются свои классы.
Data-классы - предназначены для хранения или передачи данных куда-то дальше. В Java объекты таких классов называют Data Transfer Object (DTO).
Сервисы - это классы, объекты которых, используются для выполнения однотипных задач вокруг какого-то сервиса или механизма. 
Служебные объекты - классы для взаимодействия с другими программами, такими как базы данных, очереди, кеши и многое другое.
Утилиты - вспомогательные объекты для решения разнообразных задач, например, обработки строк, преобразования Markdown в HTML и тому подобное.

Наследование - это механизм связи между классами, когда один класс, называемый наследуемым (дочерним, подклассом), как бы расширяет другой класс, называемый базовым (родительским, суперклассом).
Наследование никак не влияет на родительский класс, но значительно влияет на класс наследник. Он наследует все, что реализовано в родительском классе. 
Любой класс в Java неявно наследует класс Object. Это делает его суперклассом для всех Java-классов. Любой объект можно представить как объект типа Object.

Прямое сравнение объектов в Java почти всегда (кроме строк) будет возвращать false для разных объектов, даже если их содержимое идентично.
Сравнение объектов в Java реализуется с помощью методов equals() и hashCode(). Основные правила при работе с equals() и hashCode() звучат так:
- Если переопределяется equals(), то должен переопределяться hashCode().
- Одинаковые объекты должны возвращать одинаковый хеш-код.
- Разные объекты могут возвращать одинаковый хеш-код.

В Java разработчики часто сталкиваются с необходимостью написания повторяющегося шаблонного кода (конструкторы, геттеры и сеттеры). Это может приводить к значительному увеличению объема кода.
Lombok – это библиотека, которая позволяет убрать шаблонный код при создании классов. Lombok встраивается в процесс компиляции, во время которой он "наполняет" классы необходимыми методами.

Для получения данных извне и передачи их куда-то дальше в Java используются Data-классы. Обычно это связано с любыми внешними источниками данных, базой данных, HTTP, файлами.
Data-классы это обычные классы без поведения. Из-за этого их стараются делать неизменяемыми, или как говорят иммутабельными (immutable), для избежания случайных ошибок.
Data-классы это настолько большая часть любого приложения на Java, что в язык была внедрена новая конструкция Record (запись). Записи по своей сути Data-классы. 
Несмотря на синтаксическое превосходство, записи обладают рядом недостатков, которые делают их использование в качестве замены обычных классов неудобным. 
Сюда входят:
- Возможность работать только в неизменяемом стиле. Нет сеттеров.
- Только один конструктор со всеми полями.
- Нет наследования (иногда нужно).
- Многие библиотеки и фреймворки до сих пор не совместимы с записями.

В своей работе мы будем встречаться с двумя типами объектов, одни имеют внутреннее состояние, другие - нет.
Чем дальше в программировании, тем больше вы будете замечать, как управление состоянием объектов становится одной из самых сложных частей приложения.
Изменение одного объекта из разных потоков может приводить к непредсказуемому результату, когда данные не соответствуют тому что ожидается.
В ситуациях когда это возможно, лучше предпочитать способ с заполнением через конструктор, тогда объекты будут готовы сразу после создания.
Инварианты - правила, которым должно соответствовать внутреннее состояние объекта. Если эти правила нарушаются, значит в программе есть баги.
На практике объекты часто хранят внутри себя ссылки на другие объекты. Что может легко приводить к нарушению инвариантов без возможности это контролировать.

Состояние может быть не только у объектов, но и у классов. Этот механизм реализуется через статические поля, которые, в отличие от обычных полей, принадлежат не конкретному объекту, а всему классу.
Синтаксически такие поля отличаются от обычных наличием ключевого слова static перед указанием возвращаемого типа. Вызов этих полей происходит напрямую из класса, так же как и статических методов.
Статическое поле принадлежит классу, а не объекту. Это значит что это состояние делят между собой все объекты. Более того, доступ к этому состоянию можно получить из любой части программы в любой момент.
Статические поля достаточно опасны для использования. Так как это, по сути, глобальное состояние (глобальные переменные), то мы можем получить ситуацию, когда разные части приложения используют статические поля для хранения каких-то своих данных. 
Статический блок инициализации -  специальная конструкция внутри класса, которая вызывается при первом его использовании. static { ... }

Списки – это одна из наиболее важных структур данных, которые позволяют организовать и управлять коллекциями объектов в Java-приложениях. В отличие от массивов, коллекции умеют работать с динамическими коллекциями, в которых количество элементов со временем меняется.

Списки в Java представлены набором классов, реализующий интерфейс List, в котором описаны общие методы для работы со списками.
Коллекции – это контейнеры элементов одного типа, поэтому в коллекциях всегда нужно указывать то, что будет внутри них храниться.

Обход списка можно выполнить несколькими способами:
- С помощью цикла for
- С помощью цикла for-each
- С помощью метода forEach()

Технически for-each работает не со списками, а с объектами, реализующими интерфейс Iterable. Этот интерфейс добавлен в List и реализован в ArrayList, поэтому все происходит автоматически.
Итератор - это объект, который позволяет обходить коллекцию элементов. 

Изменение списка во время его обхода не рекомендуется из-за потенциальных ошибок и непредсказуемого поведения. По этой причине, рекомендуется создавать новый список и работать в цикле уже с ним. 

Все операции над списками можно свести к трем основным типам:
- Отображение (map) - это операция, в которой на основе одного списка, формируется другой, с таким же количеством элементов.
- Фильтрация (filter) - это операция, в результате которой на основе одного списка, формируется другой, с элементами, соответствующими условию фильтрации.
- Агрегация -— это операция нахождения какого-то значения, вычисленного на основе анализа всей коллекции.

Множественные операции над списками
- Копирование списков - самый простой способ копировать список — создать новый список с исходным списком, переданным как параметр. itemsCopy = new ArrayList<>(items);
- Сравнение списков - для правильного сравнения понадобится метод equals(). Метод equals() проверяет не только совпадение элементов, но и их порядок. items1.containsAll(items2); - проверка на вхождение
- Слияние списков - Операция выполняется с помощью метода addAll(), который добавляет в коллекцию поэлементно другую коллекцию, переданную как параметр. Этот метод меняет исходную коллекцию:
- Объединение списков - подразумевает то, что если элементы присутствуют в обоих списках, в результирующий список они попадут лишь в одном экземпляре. CollectionUtils.union()
- Пересечение списков - поиск общих элементов, то есть тех, которые есть и в первом, и во втором списке. Пересечение выполняется с помощью метода retainAll(). Этот метод меняет исходную коллекцию.
- Разность списков - коллекция, состоящая из элементов первой коллекции, которых нет во второй. CollectionUtils.subtract().

- Сортировка списков - самый простой способ отсортировать коллекцию по возрастанию — это воспользоваться методом Collections.sort().
Эта сортировка работает с примитивными типами и сортирует значения с учетом естественного порядка по возрастанию (от меньшего числа к большему). 
В случае строк это сортировка в лексиграфическом порядке, который в большинстве случаев совпадает с алфавитным порядком.
Для сортировки объектов нужно явно указывать то как выполнять сортировку.

Comparator - объект, который определяет то, как выполняется сравнение элементов. 

ArrayList - использует массив, что позволяет работать быстро в случае необходимости обращаться к произвольным элементам по индексу, но медленно, если нам нужно добавить или удалить элемент списка.
LinkedList - эта реализация списка основана на структуре данных называемой двунаправленный список. В этой структуре элементы связаны друг с другом через ссылку на следующий и предыдущий элемент.

Maps предоставляют мощный и гибкий способ хранения и управления данными в виде пар ключ-значение. 
В стандартную библиотеку входит интерфейс Map, который описывает основные методы для работы коллекции. 
Там же находятся конкретные реализации этого интерфейса, которые отличаются производительностью и потребляемыми ресурсами.
Map.of() создает неизменяемую коллекцию, то есть его элементы можно использовать, но изменять саму коллекцию нельзя. 
Хеш-код это число, которое формируется для каждого ключа добавленного в HashMap. Оно используется для того, чтобы определить место в хеш-таблице для данной пары ключ-значение.

Всего есть два основных подхода к этим обходам:
- С помощью метода forEach(). 
- С помощью преобразования HashMap в коллекцию, которая работает с for-each. Этот подход включает в себя три варианта: обход пар ключ-значения (entrySet()), обход значений values() и обход ключей keySet().

Независимо от способа обхода, важно учитывать то, что HashMap не является последовательной структурой как ArrayList. Порядок добавления элементов не влияет на их порядок обхода. 

Лямбда-функции или, как их еще называют, анонимные функции.
Лямбда-функция записывается так: () -> {}. То, что в скобках – это параметры. То, что в фигурных скобках – это тело функции. Знак -> отделяет параметры от тела.
Мы можем внутри тела лямбда-функции использовать данные взятые из внешнего контекста. Но есть ограничение. Лямбда-функции не могут изменять значение переменных, с которыми идет работа.
Лямбда-функции позволяют отделить алгоритм сортировки от логики сравнения элементов.
Метод compute() обновляет значение ключа в Map, на основе логики, заданной внутри лямбда-функции.
Метод computeIfAbsent() отличается от compute(), тем, что лямбда вызывается только в том случае, если ключа в коллекции до этого не было.
Метод computeIfPresent() отличается от compute() тем, что лямбда вызывается только в том случае, если ключ уже был добавлен в коллекцию. 
В Java все реализуется через классы, даже если снаружи так не кажется. Лямбда-функции — не исключение. 
Функциональный интерфейс — это интерфейс с единственным абстрактным методом. Он "под капотом" используется как тип для соответствующих ему лямбда-функций. 
Лямбда-функция — это объект, который реализует функциональный интерфейс, где методом является определение лямбда-функции.
Ссылка на метод (Method Reference) – это сокращенная форма лямбда выражения для вызова методов. То есть это синтаксический сахар, который делает код короче и проще для чтения.
Общий синтаксис ссылки на метод выглядит так: Name::methodName. Где Name может быть как объектом так и классом, в зависимости от того, ссылку на что мы хотим получить и как это будет использовано потом. 

objectName::methodName // (v) -> objectName.methodName(v)
ClassName::staticMethodName // (v) -> ClassName.staticMethodName(v)
ClassName::methodName // (v) -> v.methodName()

 



Числа
  - Натуральные — это целые числа от 1 и больше
  - Рациональные — это числа с точкой, например, 0.5  ( операции с плавающими числами неточны, но эту точность можно регулировать. )


Диспетчеризация динамических методов представляет собой механизм, с помощью которого вызов переопределенного
метода распознается во время выполнения, а не на этапе компиляции. Динамическая диспетчеризация методов важна, потому что именно так в Java обеспечивается полиморфизм во время выполнения.

Object представляет собой супер-класс для всех остальных классов. Это означает, что ссылочная переменная типа Object может ссылаться на объект любого другого класса.

Все классы в Java принадлежат какому-то пакету. Если оператор package от-сутствует, тогда используется стандартный пакет.

Исключение - это ошибка, которая возникает во время выполнения.
Системные исключения автоматически генерируются исполняющей средой Java. Для ручной генерации исключения используйте ключевое слово throw.

Поток данных (stream) — это абстракция, которая либо производит, либо потребляет информацию. Поток связан с физическим устройством посредством системы ввода-вывода Java.

