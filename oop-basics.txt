--- О курсе ---

Классы в Java одна из ключевых концепций, вокруг которой строится код. Буквально весь код описывается внутри классов без возможности выбора. Этим Java сильно отличается от многих других языков, где классы добавляются только по необходимости либо их нет вообще.

--- Статические методы ---

Одна из базовых конструкций в программировании - функция. С помощью функций мы выделяем повторяющиеся блоки кода и вводим новые операции, которые не заложены в язык.
С Java все немного сложнее. Она не позволяет создавать обычные функции. Java требует наличия класса для определения функций, которые, в этом случае, называются методами. 

Если вызов метода идет из того же класса, где он определен, то указывать имя класса перед ним не нужно:

class App {
    public static String greeting() {
        return "just a string";
    }

    public static void main(String[] args) {
        // Тот же класс, поэтому имя не обязательно
        greeting();
        // Хотя, чисто технически, его можно поставить
        // App.greeting();
    }
}

Методы, определенные как static, называют статическими.

--- Объекты ---

Упрощенно, с помощью классов описываются категории объектов, например, "кошки" или "адреса" или даже "строки". На базе классов создаются объекты, из которых потом строится логика работы кода.

var user = new User("Danil", "Miloshin");

В коде мы создаем объект "пользователь" с указанными именем и фамилией. Делается это с помощью ключевого слова new, после которого идет имя класса со скобками, как при вызове обычной функции. Этот объект записывается в переменную и становится доступен для работы. Дальше, в зависимости от того как был написан класс, мы можем выполнять разные действия с ним - менять свойства и вызывать методы.

При таком подходе, программа превращается в набор объектов, которые взаимодействуют друг с другом. Через эти объекты выражаются процессы, происходящие в проекте. 

В программировании такой стиль программирования называется объектно-ориентированным (ООП).

-- Связь с реальным миром --

В интернете много вопросов от новичков, что такое ООП (объектно-ориентированное программирование) и как его понять. Один из самых популярных ответов — рассказ про моделирование реального мира через классы. Вот у нас есть машина, вот дом, вот мы для них пишем классы. Такое объяснение больше путает, чем помогает. Классы действительно используются для моделирования, но только не реального мира, а конкретной предметной области. Например, пользователь с точки зрения бухгалтера и системы заказа пиццы — это абсолютно разные сущности. У них разный набор свойств, разное поведение и разное предназначение. 

--- Классы ---

Разберемся в устройстве классов из которых создают объекты на примере кода:

var user = new User("Danil", "Miloshin");

// метод возвращает имя
user.getFirstName(); // "Danil"

Первая строчка – это создание объекта из класса. За это отвечает оператор new.
Затем вызывается конструктор класса, специальный метод, определенный внутри класса и имеющий такое же имя как и класс. Конструктор нужен для инициализации объекта. 

class User {
    public String firstName;
    public String lastName;
}

Свойства выглядят как переменные, определенные внутри класса («на уровне класса») с добавленными к ним модификаторами доступа, как у методов.

class User {
    public String firstName;
    public String lastName;

    User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}

Обратите внимание на this — это указатель на текущий объект. Через него мы можем читать и записывать свойства, а также вызывать методы нашего объекта. 
Свойства хранят данные объектов, причем у каждого объекта они свои.

-- Конструктор по умолчанию --

Иногда у объектов начальная инициализация необязательна, либо ее вообще нет. В таком случае определять конструктор не нужно, так как Java определяет для каждого класса конструктор по умолчанию. Это обычный конструктор, но без параметров.

-- Перегрузка конструктора --

Перегрузка методов распространяется и на конструктор. В зависимости от ситуации можно добавлять любые конструкторы, которые удобно.

--- Доступ к свойствам объекта ---

В реальном программировании к свойствам не принято обращаться напрямую. Почти всегда их делают приватными, то есть закрытыми от прямого внешнего воздействия. Для доступа определяют "геттеры" и "сеттеры".

var user = new User("Jonny", "Depp");
// Геттер
user.getFirstName(); // "Jonny"
// Сеттер
user.setFirstName("Monika"); // "Jonny"

Пример выше можно упростить, так как this не является обязательным. Java понимает, когда имя совпадает с именем свойства и использует его.

Кроме методов доступа к свойствам, классы позволяют описывать любые другие методы, которые нам нужны. Благодаря им и реализуется логика программы.

Существует одна ситуация, в которой использование this обязательно, оно связано с совпадением имени свойства с локальным именем переменной. Например, в такой ситуации:

class User {
    private String firstName;

    // Имена параметров совпадают с именами свойств
    User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}

-- Соглашения и правила --

При работе с классами нужно придерживаться некоторых соглашений:

1.Один файл – один класс. Имя файла и класса совпадают.
2.Классы начинаются с заглавной буквы. Методы с прописной за исключением конструктора.
3.Сеттеры и Геттеры создаются путем добавления приставки set и get
4.Свойства всегда приватные

--- Ссылочные типы данных ---

Классы в Java особым образом связаны с типами данных.

User user = new User("Danil", "Miloshin");

типом переменной user будет User

В Java все типы данных делятся на две категории: примитивные и ссылочные. К примитивным относятся все виды чисел, символы и логический тип данных (булеан). К ссылочным - классы, массивы, строки. В зависимости от категории, значительно меняется поведение кода и об этом нужно знать. 

-- Значение по умолчанию --

Примитивные данные всегда имеют значение, даже если они определяются без инициализации:

int a;
System.out.println(a); // => 0

У ссылочных в качестве значения по умолчанию используется null. Это специальное значение, которое может быть использовано в качестве любого объекта

User u;
System.out.println(u); // => null

-- Присваивание --

Примитивное значение всегда копируется при присваивании:

// Содержимое a и b не связаны
var a = 5;
var b = a;

Ссылочные же данные не копируются. При присваивании переменные начинают указывать (ссылаться) на один и тот же объект:

var u1 = new User("Igor", "Mon");
// Обе переменные ссылаются на один тот же объект
var u2 = u1;

Больше всего это проявляется при передаче данных в методы и их возврате оттуда. Ссылочное значение передается по ссылке, а значит его можно изменить изнутри метода.

-- Сравнение --

Примитивные данные сравниваются по значению. Пять всегда равно пяти, истина всегда равна истине:

var a = 5;
var b = 5;

a == b; // true

Ссылочные сравниваются по ссылкам, а не на основе содержимого. Объекты равны только сами себе.

var u1 = new User("Igor", "Mon");
var u2 = new User("Igor", "Mon");

// Проверяется только ссылка, указывает она на тот же объект или нет
u1 == u2; // false

--- Строки ---

Среди встроенных в Java типов данных, строки стоят особняком. У них настолько необычное поведение, что его нужно разбирать отдельно. Строки — это объекты класса java.lang.String, а не примитивные значения, как можно было бы подумать. Но они существуют в двух формах для производительности. Иногда строки ведут себя как примитивные значения, иногда как объекты.

// Такой способ работы называется String Literal
var name1 = "Hexlet";
name1.toUpperCase(); // "HEXLET"

// Этот способ называется String Object
var name2 = new String("Hexlet");
// Тут то же самое
name2.toUpperCase(); // "HEXLET"

С другой стороны, если мы попытаемся сравнить две строки, то получим неожиданный результат:

var name1 = "Hexlet";
var name2 = "Hexlet";

name1 == name2; // true

По логике, описанной в этом уроке, два создания строки должны приводить к созданию двух разных объектов с разными ссылками. В случае строк все хитрее из-за требований к производительности.
Если строка создается как String Literal, то объект создается только при первом появлении такого значения строки. Второе и последующие создания строки с уже существующим значением будут ссылаться на ту первую строку.
Но если строки созданы как объекты сразу, например через new String(), то они будут сравниваться по стандартной схеме.

Общее правило звучит так. Если у нас нет цели сравнивать ссылки, то всегда используем метод equals(), так мы защитимся от случайных ошибок.

--- Классы обертки ---

В Java у каждого примитивного типа есть соответствующий "объектный" тип. Например, для int существует пара в виде Integer. Последний представлен классом и называется классом-оберткой.

int value = 42; // int
Integer value = new Integer(42); // Integer

То же самое и для всех остальных примитивных типов:

Примитивный тип	Класс-обертка

byte          	Byte
short	        Short
int	        Integer
long	        Long
float	        Float
double	        Double
char	        Character
boolean	        Boolean

Классы-обертки нужны для нескольких целей, которых по разным причинам невозможно решить с помощью примитивных типов.

-- Совместимость и единообразие --

Многие возможности Java завязаны на то, что типы представлены классами, только в этом случае они смогут быть использованы как параметры методов или их возвращаемое значение.

-- null --

Примитивные типы всегда содержат какое-то осмысленное значение. На практике же, значение может быть не определено. Особенно часто такое происходит, когда данные поступают из внешних источников. Для представления таких данных нужно специальное обозначение и возможность использовать это значение. В Java, как и в большинстве других языков, таким значением является null. Его можно использовать только с классами-обертками.

// Ошибка!
int value = null;

// Работает
Integer value = null;

По этой причине, множество методов ожидает на вход классы-обертки, а не примитивные типы.

-- Утилиты и значения --

Классы-обертки содержат в себе полезные значения и методы, для своих типов. 

-- Почему так устроено? --

Зачем тогда нужны примитивные типы если есть классы-обертки? Ответ кроется в производительности. Работа с примитивными типами как объектами значительно ухудшает производительность программы. Поэтому по умолчанию создаются объекты именно примитивных типов.

-- Боксинг и анбоксинг (Boxing and Unboxing) --

По логике, такая система должна приводить к постоянному конвертированию типов в коде, так как где-то создаются примитивные типы, где-то нужны классы-обертки и наоборот. К счастью, этого почти никогда не происходит благодаря механизму автобоксинга (Autoboxing). Тип преобразуется автоматически в тот момент, когда это нужно.

int value = 42;
// int -> Integer
Integer wrappedInt = value; // Autoboxing

// Integer ->
int unboxedInt = wrappedInt; // Auto-unboxing

По этой схеме работает и передача аргументов в методы и возврат из них.












































