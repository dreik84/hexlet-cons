--- О курсе ---

Умение создавать классы и пользоваться объектами важная часть объектно-ориентированного программирования, но недостаточная для того, чтобы писать по-настоящему хорошо организованные программы. В этом нам помогут принципы объектно-ориентированного дизайна, которые включают в себя несколько важных элементов:

- Предметно-ориентированное программирование.
- Шаблоны проектирования.
- И даже антипаттерны. Описание того как не надо писать программы.

-- Шаблоны проектирования (Паттерны) --

Паттерны - это принципы организации кода, для решения каких-то распространенных задач в программировании. В общем понимании паттерны не являются спецификой ООП, паттерны встречаются везде и бывают как очень локальными, для небольших кусков кода, так и глобальными. Их часто называют архитектурными, такие паттерны относятся к организации каких-то больших частей или даже всего приложения.

-- Предметно-ориентированное программирование --

Любое прикладное приложение работает с какой-то конкретной предметной областью.
Во многом прикладное программирование занимается тем, что перекладывает предметную область на код.

--- Билдер (Builder) ---

Билдер (Builder) это шаблон проектирования, который используется там, где есть необходимость постепенного создания объекта, таким образом, чтобы гарантировалась его целостность, то есть то, что он создан целиком и полностью так, как это предполагалось.

@Builder
@Data
public class Car { // Ford
    private String model;
    private String engine;
    private String interior;
    private boolean hasSunroof;
    private String color = "Black";
}

Lombok включает аннотацию @Builder, которая добавляет билдер прямо в наш класс.

var car = Car.builder()
    .model("Mustang")
    .engine("3.6")
    .interior("Leather")
    .hasSunroof(true)
    .color("Silver Metallic")
    .build();

Здесь вначале вызывается статический метод builder(), который возвращает объект для сборки. Затем, после того как объект собран вызывается build(), который возвращает наш объект.

--- Синглтон (Singleton) ---

Синглетон это широкоизвестный шаблон проектирования используемый в том случае, когда нужно ограничить класс созданием ровно одного объекта. Реализация этого шаблона базируется на том, что конструктор делается приватным. Объект такого класса можно получить только через статический метод getInstance().

public class Singleton {
    // Инстанс класса
    private static Singleton instance;

    // Приватный конструктор
    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    // Другие методы класса
}

Singleton::getInstance();

В этом коде объект класса хранится в приватном статическом свойстве instance. Получить этот объект можно только с помощью статического метода getInstance(), который создает объект в случае необходимости. Таким образом достигается условие наличия ровно одного объекта этого класса на запущенное приложение.

Несмотря на свою простоту и привлекательность, опыт многих приложений показал, что синглетон создает больше проблем, чем помогает. Фактически, синглетон это глобальная переменная со всеми вытекающими минусами.

- Классы начинают неявно зависеть от синглетона, который используется в коде напрямую.
- Любая часть приложения в любой момент времени может изменить синглетон, что может привести к неожиданным последствиям и сложностям в отладке.
- Обеспечение потокобезопасности синглетона в многопоточных приложениях может стать проблемой. Плюс это негативно влияет на производительность.

Из-за этих и многих других проблем, синглотон называют не паттерном, а антипаттерном. Поэтому программисты рекомендуют отказаться от синглетона в пользу инъекции зависимостей.


































