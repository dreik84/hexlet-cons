--- Введение ---

Списки – это одна из наиболее важных структур данных, которые позволяют организовать и управлять коллекциями объектов в Java-приложениях. В отличие от массивов, коллекции умеют работать с динамическими коллекциями, в которых количество элементов со временем меняется.

--- ArrayList ---

Наиболее часто используемая коллекция в Java – это список элементов с произвольным доступом. Такой список во многом напоминает массив, но с возможностью динамического добавления элементов.

Списки в Java представлены набором классов, реализующий интерфейс List, в котором описаны общие методы для работы со списками, такими как проверка на существование, добавление, извлечение, замена и другими.

Сами классы, в первую очередь, отличаются друг от друга способом организации (структурой данных) внутри себя. Это происходит из-за того, что не существует универсально эффективного способа создать динамический список. Создатели языка Java решили предложить программистам набор разных реализаций, которые программисты должны выбирать в зависимости от того, какая реализация окажется наиболее эффективной для их ситуации.На практике такое происходит не часто и в большинстве случаев используется ArrayList.

import java.util.ArrayList;

var items = new ArrayList<String>();

add() - добавление элемента в коллекцию
contains() - проверяет наличие элемента в коллекции.
get() - возвращает элемент по его индексу. Индексация, как и в массивах, начинается с нуля. Обращение к несуществующему индексу приводит к исключению.
size() возвращает количество элементов.

Кроме добавления элементов, их можно изменять и удалять. Метод set() заменяет элемент списка по указанному индексу на новый.
Метод remove() удаляет элемент списка на основе его индекса.

Если у списка есть начальный набор элементов и он достаточно большой, то их можно указать сразу с помощью метода List.of(). Единственное нужно учитывать, что List.of() создает неизменяемый список, то есть его элементы можно использовать, но изменять сам список нельзя. 

-- Apache Commons Collections --

Стандартная библиотека предоставляет множество полезных методов для работы со списками, но даже их недостаточно для всех возникающих ситуаций. Поэтому полезно знать про библиотеку commons-collections4, в которой содержится огромное количество полезных методов на все случаи жизни.

--- Обход списков ---

Большинство операций над списками строятся вокруг их обхода с перебором всех элементов.
Обход списка можно выполнить несколькими способами:

С помощью цикла for
С помощью цикла for-each
С помощью метода forEach()

-- Обход с помощью цикла for --

В этом случае движение по списку идет за счет счетчика цикла, который одновременно является индексом в списке.
Такой вид обхода полезен тогда, когда во время каждой итерации нам нужно обращаться не только к текущему элементу списка, но и, например, соседним. В остальных ситуациях проще использовать цикл for-each

-- Обход с помощью цикла for-each --

for-each прячет от нас процесс перебора, так, что на каждой итерации мы работаем только с текущим элементом
Технически for-each работает не со списками, а с объектами, реализующими интерфейс Iterable. Этот интерфейс добавлен в List и реализован в ArrayList, поэтому все происходит автоматически.

Зачем нужен отдельный объект для обхода коллекции? Дело в том, что во время обхода нужно помнить позицию текущего элемента. В случае обычного цикла мы управляем этим сами через счетчик цикла. Итератор же позволяет скрыть эту логику внутри, за счет сохранения текущей позиции. 

-- Изменение списка во время обхода --

В общем, изменение списка во время его обхода не рекомендуется из-за потенциальных ошибок и непредсказуемого поведения.
По этой причине, рекомендуется создавать новый список и работать в цикле уже с ним.

--- Списки в действии ---

Все операции над списками можно свести к трем основным типам:

- Отображение.
- Фильтрация.
- Агрегация.

-- Отображение (map) --

Отображение — это операция, в которой на основе одного списка, формируется другой, с таким же количеством элементов.

-- Фильтрация (filter) --

Фильтрация — это операция, в результате которой на основе одного списка, формируется другой, с элементами, соответствующими условию фильтрации. 

Фильтрация в чистом виде работает так:

- Новый список по размеру либо такой же, как и исходный, либо меньше, вплоть до того, что он может быть пустым.
- Фильтрация не меняет сами элементы, она только убирает неподходящие. Изменение элементов возможно только тогда, когда фильтрация объединена — например, с отображением.

-- Агрегация --

Агрегация — это операция нахождения какого-то значения, вычисленного на основе анализа всей коллекции. 

Но агрегация не ограничивается только такими операциями. Более того, результатом агрегации может быть сложная структура, а не простое значение. Например, мы можем захотеть сгруппировать всех пользователей по году рождения. Несмотря на различия, все эти операции сводятся к полному анализу элементов коллекции, так как результат агрегирующей операции зависит от каждого элемента.

--- Списки в определении типов ---

На примере коллекций, мы первый раз столкнулись с типами данных, которые завязаны на интерфейс и имеют несколько его реализаций. Определение свойств и методов с такой структурой отличается от того, как мы до этого работали с примитивными типами.

Правильным выходом из этой ситуации будет завязка не на конкретную реализацию ArrayList, а на интерфейс List.
Фактически в этом и есть смысл интерфейсов. Реализация может поменяться, но код от этого меняться не должен, если интерфейс не меняется.
Сегодня мы решили использовать ArrayList, а завтра захотели поменять его на LinkedList, потому что так будет эффективнее. Код по-прежнему будет работать.

--- Множественные операции над списками ---

Помимо рассмотренных операций над списком, есть набор операций, которые выполняются между двумя и более списками. Среди них:

- Расширение одного списка элементами другого списка.
- Поиск общих элементов в двух и более списках.
- Поиск элементов, которые есть в одном списке, но нет в другом.
- Поиск элементов, которые уникальны для двух списков

-- Копирование списков --

Самый простой способ копировать список — создать новый список с исходным списком, переданным как параметр:

var items = new ArrayList<String>();
var itemsCopy = new ArrayList<>(items);

В примере выше получилось два независимых списка. Изменение одного не приводит к изменениям другого. Но так происходит не всегда. Если список состоит из объектов, которые можно менять, тогда изменение объекта в одном списке, повлияет и на другой.

-- Сравнение списков --

Для правильного сравнения понадобится метод equals()

items1.equals(items2)

Метод equals() проверяет не только совпадение элементов, но и их порядок.

Кроме полного сопоставления, мы можем проверять вхождение одного списка в другой:

items1.containsAll(items2)

-- Слияние списков --

Операция выполняется с помощью метода addAll(), который добавляет в коллекцию поэлементно другую коллекцию, переданную как параметр.

items1.addAll(items2)

Иногда нужно получить общий список, не меняя исходного. В таком случае можно воспользоваться копированием.

-- Объединение списков --

Операция объединения списков отличается от операции слияния. Объединение подразумевает то, что если элементы присутствуют в обоих списках, в результирующий список они попадут лишь в одном экземпляре. Подобная операция реализуется с помощью CollectionUtils.union()

var items3 = CollectionUtils.union(items1, items2);

-- Пересечение списков --

Под пересечением понимается поиск общих элементов, то есть тех, которые есть и в первом, и во втором списке. Пересечение выполняется с помощью метода retainAll(). Этот метод меняет исходную коллекцию.

items1.retainAll(items2)

Если исходные коллекции должны остаться в неизменном виде, то снова поможет копирование списков.

var items3 = CollectionUtils.intersection(items1, items2);

-- Разность списков --

Под разностью понимается коллекция, состоящая из элементов первой коллекции, которых нет во второй. Java не предоставляет метода для решения этой задачи, поэтому у нас есть два варианта, либо реализовывать эту логику самостоятельно на циклах, либо воспользоваться CollectionUtils.subtract().

var items3 = CollectionUtils.subtract(items1, items2);

--- Сортировка списков ---

Отдельным пунктом в работе с коллекциями стоит сортировка. В Java встроены все необходимые элементы для реализации сортировок любой сложности.

-- Простая сортировка --

Самый простой способ отсортировать коллекцию по возрастанию — это воспользоваться методом Collections.sort(). Этот метод принимает на вход коллекцию и меняет ее напрямую.

Collections.sort(temperatures);

Эта сортировка работает с примитивными типами и сортирует значения с учетом естественного порядка по возрастанию. Под естественным порядком понимается движение от меньшего числа к большему. В случае строк это сортировка в лексиграфическом порядке, который в большинстве случаев совпадает с алфавитным порядком.

-- Сортировка по условию --

Сортировка может быть не только в прямом порядке, но и обратном. Кроме того, нам могут понадобиться разные условия сортировки, например без учета регистра, по какому-то конкретному свойству объекта и так далее. Для реализации подобных сортировок в Collections добавлен метод sort() с двумя параметрами. Второй параметр нужен для передачи Comparator, объект, который определяет то, как выполняется сравнение элементов.

Collections.sort(temperatures, Collections.reverseOrder());

А вот сортировка без учета регистра:

Collections.sort(languages, String.CASE_INSENSITIVE_ORDER);

-- Сортировка объектов --

Для сортировки объектов нужно явно указывать то как выполнять сортировку, так как, в отличии, от тех же чисел, не существует универсального способа сортировки объектов. Например, пользователей на сайте можно выводить по возрасту, по дате регистрации или количеству пройденных курсов.

Java предоставляет удобный способ выполнять такую сортировку с помощью лямбда-функций.





































