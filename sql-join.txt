Правильно организованные табличные базы хранят данные по правилам нормализации данных. В нормализованном виде информация о разных сущностях хранится в разных таблицах.

---  Несколько таблиц ---

Как правило, таблицы содержат однотипные данные, которые могут относиться к одной сущности. Если добавляется новая сущность, то добавляется новая таблица. Каждая таблица содержит информацию о сущности независимо от других таблиц.

Таблицы не имеют физической связи. Изменение данных в одной таблице, не приводит к изменениям в других. Но таблицы могут быть связаны по смыслу.

-- Связь один ко многим --

Связь "один ко многим" означает, что каждому элементу из одной таблицы соответствует несколько элементов из другой таблицы.

-- Один к одному --

Связь "один к одному" означает, что каждому элементу из одного набора соответствует только один элемент из другой таблицы. 

-- Многие ко многим --

Связь "многие ко многим" (или "много к многим") означает, что несколько элементов из одной таблицы могут соответствовать нескольким элементам из другой таблицы. 

Для представления такой связи часто используется связующая таблица, которая содержит значения обоих наборов элементов.

--- Типы соединения таблиц ---

Соединения — важная часть языка SQL. С помощью соединений мы можем связать строки одной таблицы со строками другой.

В языке SQL есть пять видов инструкции JOIN — типов соединения таблиц:

CROSS JOIN
INNER JOIN
LEFT JOIN или LEFT OUTER JOIN
RIGHT JOIN или RIGHT OUTER JOIN
FULL JOIN или FULL OUTER JOIN

Тип соединения нужно выбирать исходя из того, какой результат мы хотим получить.

-- Соединение без условия --

В эту группу попадает только CROSS JOIN — это соединение строит все возможные комбинации строк из двух таблиц.

SELECT
    color_name,
    material_name
FROM colors
CROSS JOIN materials;

-- Соединения с условием --

В эту группу попадают остальные типы: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN. 
В их случаях в результат попадают не все сочетания, а только те, которые удовлетворяют специальному условию соединения.

-- Выбор типа соединения с условием --

В результат соединения с условием всегда попадают валидные пары строк, то есть удовлетворяющие условию соединения. 
Но конкретный тип соединения выбирают исходя из того, как нужно поступить со строками без пары.

Виды соединений

тип соединения	               валидные пары	строки без пары из TableA	строки без пары из TableB
TableA INNER JOIN TableB	добавляются	  не добавляются	           не добавляются
TableA LEFT JOIN TableB	        добавляются	    добавляются	                   не добавляются
TableA RIGHT JOIN TableB	добавляются	  не добавляются	             добавляются
TableA FULL JOIN TableB	        добавляются	    добавляются                      добавляются

По правилам SQL, строки без пары добавляются в результат всего один раз, а вместо недостающих значений устанавливается NULL.

-- INNER JOIN --

Это соединение отбирает только такие пары строк, которые удовлетворяют специальному условию соединения.

SELECT
    author_name,
    title
FROM books
INNER JOIN authors ON book_author_id = author_id;

-- LEFT JOIN --

LEFT JOIN используют, когда нужно построить соединение, в котором обязательно будут все строки из первой таблицы. 
Если для строки из первой таблицы нет подходящих пар во второй таблице, то вместо данных из второй таблицы будут подставлены NULL-значения.

SELECT
    dep.name AS department,
    emp.name AS employee
FROM departments AS dep
LEFT JOIN employees AS emp ON
    dep.department_id = emp.department_id;

-- RIGHT JOIN --

RIGHT JOIN работает похожим образом, но только в результат попадают все строки из второй таблицы, а не из первой.

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
RIGHT JOIN employees AS emp ON
    dep.department_id = emp.department_id;

-- FULL JOIN --

Полное внешнее соединение используют, когда в результате должны быть все строки из обеих таблиц, даже если у них нет подходящей пары. Результат FULL JOIN включает в себя результаты INNER JOIN, LEFT JOIN и RIGHT JOIN.

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
FULL JOIN employees AS emp ON
    dep.department_id = emp.department_id;

--- CROSS JOIN (перекрестное соединение) ---

Этот тип соединения позволяет получить все возможные сочетания строк из двух таблиц.

SELECT
    color_name,
    material_name
FROM colors -- первая таблица
CROSS JOIN materials; -- вторая таблица

CROSS JOIN соединяет каждую строку из первой таблицы с каждой строкой из второй таблицы. Поэтому число строк в результате — это произведение количества строк из первой таблицы с количеством строк из второй таблицы. 

--- INNER JOIN (внутреннее соединение) ---

Это соединение возвращает сочетания строк из двух таблиц, которые удовлетворяют условию соединения.

SELECT
    author_name,
    title
FROM books -- первая таблица
INNER JOIN authors -- вторая таблица
    ON book_author_id = author_id; -- условие соединения таблиц

Для каждой строки из первой таблицы INNER JOIN пытается найти строки из второй таблицы так, чтобы выполнилось условие соединения. Если во второй таблице будет несколько подходящих строк — в результат попадут все такие пары. Если в первой или во второй таблице есть строки, для которых не нашлась подходящая пара — они не попадут в результат.

--- Псевдонимы (aliases) ---

При работе со сложными запросами легко запутаться, а при работе с соединениями запутаться может даже СУБД. 
Чтобы сделать запросы более понятными и избежать некоторых ошибок компиляции запроса, используют псевдонимы.

-- Неоднозначность запроса и способы ее исправления --

Дело в том, что в таблицах есть столбцы с одинаковыми именами и они используются в нашем запросе, поэтому его нельзя однозначно интерпретировать.

SELECT
    name,
    name -- непонятно, откуда какой столбец надо взять
FROM employees
INNER JOIN departments ON
    department_id = department_id; -- непонятно, откуда какой столбец надо взять

-- Имя таблицы перед именем столбца --

Мы можем добавить имя таблицы перед именем столбца во всех местах, где есть неоднозначность:

SELECT
    employees.name,
    departments.name -- добавили имена таблиц
FROM employees
INNER JOIN departments ON
    employees.department_id = departments.department_id; -- добавили имена таблиц

-- Псевдонимы для таблиц --

Вместо имени таблицы можно использовать собственный псевдоним:

SELECT
    emp.name,
    dep.name
FROM employees AS emp -- объявили псевдоним для employees
INNER JOIN departments AS dep ON -- объявили псевдоним для departments
    emp.department_id = dep.department_id;

Псевдонимы объявляются сразу после имени таблицы в секциях FROM и JOIN с помощью ключевого слова AS. Объявленный псевдоним можно использовать в остальных секциях запроса.

-- Псевдонимы для столбцов --

Еще один вид псевдонимов — это псевдонимы для столбцов:

-- добавили псевдонимы для столбцов
SELECT
    emp.name AS employee,
    dep.name AS department
FROM employees AS emp
INNER JOIN departments AS dep ON
    emp.department_id = dep.department_id;

Псевдонимы для столбцов объявляются в секции SELECT с помощью ключевого слова AS.

Существует несколько ситуаций, когда псевдонимы для столбцов бывают очень полезны.

Во-первых, псевдонимы однозначно определяют имена столбцов в результате запроса. Это полезно, потому что в спорных ситуациях имена столбцам дает СУБД. Но эти имена обычно не очень информативны и разные СУБД назначают их по-разному.

Во-вторых, объявленные псевдонимы столбцов можно использовать в секциях GROUP BY и ORDER BY. Это особенно полезно для вычисляемых столбцов — не нужно дублировать вычисления.

--- INNER JOIN и WHERE ---

С помощью INNER JOIN мы можем связать каждую книгу с ее автором, а оператор WHERE позволяет отфильтровать строки по заданному условию.

SELECT
    authors.author_name,
    books.title
FROM books
INNER JOIN authors
    ON
        books.author_id = authors.author_id -- связываем книги с их авторами
WHERE
    books.language = 'Russian' -- издание на русском языке
    AND authors.origin != 'Russia' -- иностранный автор

Логически СУБД выполняет запрос в следующем порядке:

INNER JOIN — сначала выполняется соединение двух таблиц по условию: books.author_id = authors.author_id
WHERE — затем применяется фильтрация строк с условием: books.language = 'русский' AND authors.origin != 'Россия'
Отбрасываются все столбцы кроме author_name и title

В реальности СУБД может изменить порядок операций, чтобы получить такой же результат, но быстрее.

--- INNER JOIN и GROUP BY ---

Запросы, в которых одновременно используются и соединение, и группировка, часто используются для составления сводных отчетов.
Допустим, мы хотим построить отчет, в котором будет указано название отдела, количество сотрудников в нем и суммарная зарплата всех сотрудников отдела.

SELECT
    dep.name AS department, -- название отдела
    -- количество сотрудников в отделе
    COUNT(emp.employee_id) AS employees_count,
    SUM(emp.salary) AS total_salary -- суммарная зарплата отдела
FROM departments AS dep
INNER JOIN employees AS emp
    ON
        -- связываем сотрудников с отделами
        dep.department_id = emp.department_id
GROUP BY dep.name -- группировка по отделам

Логически СУБД выполняет запрос следующим образом:

Выполняется соединение двух таблиц по условию: dep.department_id = emp.department_id.
Полученные строки разделяются на группы с одинаковым названием отдела — dep.name.
Для каждой группы рассчитываются количество сотрудников в группе — COUNT(emp.employee_id) и суммарная зарплата — SUM(emp.salary).

--- LEFT JOIN (Левое внешнее соединение) ---

LEFT JOIN используют, когда нужно построить соединение, в котором обязательно будут все строки из первой таблицы. 
Если для строки из первой таблицы нет подходящих пар во второй таблице, то вместо данных из второй таблицы будут подставлены NULL-значения.

SELECT
    dep.name AS department,
    emp.name AS employee
FROM departments AS dep
LEFT JOIN employees AS emp ON -- левое внешнее соединение
    dep.department_id = emp.department_id

Результат содержит все строки из первой таблицы, даже те, которые не удалось связать.

-- RIGHT JOIN --

Запрос с RIGHT JOIN работает так же, как и LEFT JOIN. Но в результат попадают все строки из второй (правой) таблицы, а не из первой (левой).

SELECT
    dep.name AS department,
    COUNT(emp.employee_id) AS employees_count
FROM employees AS emp
RIGHT JOIN departments AS dep ON
    dep.department_id = emp.department_id
GROUP BY dep.name

--- ANTI JOIN (левое соединение с NULL) ---

Цель ANTI JOIN — отобрать строки, у которых нет пары при соединении таблиц. Этот прием реализуется с помощью левого или правого внешнего соединения и фильтрации. 
Для фильтрации мы используем столбец, который не может принимать значение NULL, например, первичный ключ. Так мы можем однозначно отличить строки без пары.

SELECT cus.customer_name
FROM customers AS cus
LEFT JOIN orders AS ord
    ON
        cus.customer_id = ord.customer_id
WHERE ord.order_id IS NULL -- отбираем только покупателей без заказа

После фильтрации мы получили список клиентов, которые не сделали ни одного заказа.

Также прием ANTI JOIN можно реализовать и с помощью RIGHT JOIN. 
В этом случае мы получим все те строки из второй (правой) таблицы, которые не были связаны со строками из первой (левой) таблицы.

--- FULL JOIN (полное соединение) ---

Полное внешнее соединение — FULL OUTER JOIN или сокращенно FULL JOIN. Результат этого соединения содержит все строки из обеих таблиц:

- Все пары строк, которые удовлетворяют условию соединения — как в INNER JOIN
- Все строки без пары из первой таблицы
- Все строки без пары из второй таблицы

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
FULL JOIN employees AS emp ON
    dep.department_id = emp.department_id;

Результат содержит всех сотрудников с отделами, все отделы без сотрудников и всех сотрудников без отделов.

Полное внешнее соединение используют, когда в результате должны быть все строки из обеих таблиц, даже если у них нет подходящей пары. 
Результат FULL JOIN включает в себя результаты INNER JOIN, LEFT JOIN и RIGHT JOIN.

--- SELF JOIN (соединение таблицы с собой) ---

SELF JOIN — это прием, когда выполняется соединение таблицы с самой собой. 
СУБД обрабатывает такие запросы так, будто мы соединяем две разные таблицы с одинаковой структурой и данными.

SELECT
    empl.employee_name,
    mngr.employee_name AS manager_name
FROM employees AS empl
LEFT JOIN employees AS mngr ON
    empl.manager_id = mngr.employee_id

В этом запросе таблица employees соединяется сама с собой. Этот прием называется SELF JOIN. 
Логически этот запрос работает так же, как если бы мы соединяли таблицу со своей полной копией.

В SELF JOIN запросах одна и та же таблица выполняет разные роли. Поэтому необходимо использовать псевдонимы для таблиц, чтобы явно разграничить эти роли.
В нашем запросе используется LEFT JOIN, но это не принципиально. Другие виды соединений также поддерживают соединение таблицы с самой собой.

--- Соединение трех и более таблиц ---

SELECT
    drv.driver_name AS driver, -- имя водителя
    pas.passenger_name AS passenger, -- имя пассажира
    rd.price AS ride_price -- стоимость поездки
FROM rides AS rd
INNER JOIN drivers AS drv
    ON -- первое соединение
        rd.driver_id = drv.driver_id
INNER JOIN passengers AS pas ON -- второе соединение
    rd.passenger_id = pas.passenger_id

Чтобы выполнить соединение с третьей таблицей, мы добавили в запрос еще одну секцию INNER JOIN ... ON .... Добавляя секции, мы можем соединить произвольное число таблиц.

--- Подзапросы ---

Подзапросы — это запросы внутри запросов. Они позволяют использовать результат одного запроса внутри другого запроса.

SELECT emp.name AS employee
FROM employees AS emp
WHERE emp.department_id = (
    SELECT dep.department_id
    FROM departments AS dep
    WHERE dep.name = 'Development Department'
)

Запрос, который находится внутри другого запроса, называется подзапросом или вложенным запросом. 
Подзапросы можно использовать почти в любом месте основного запроса, где можно использовать обычные значения. Нужно только окружить подзапрос круглыми скобками.

-- Подзапросы, которые возвращают набор значений --

Подзапросом можно заменить не только простое значение, но и набор значений. 

SELECT emp.name AS employee
FROM employees AS emp
WHERE emp.department_id IN (
    SELECT dep.department_id
    FROM departments AS dep
    WHERE dep.city = 'Vladivostok'
);

Подзапрос здесь возвращает список идентификаторов отделов, расположенных в определенном городе.

Даже если подзапрос возвращает одну или ноль строк, с ним все равно можно работать как с набором значений. Например, пользоваться операторами IN, NOT IN, EXISTS и NOT EXISTS.

-- Коррелированные подзапросы --

Если подзапрос обращается к полям основного запроса, то его называют коррелированным. 

SELECT
    main_query_department.name AS department_title,
    (
        SELECT COUNT(*)
        FROM employees AS subquery_employee
        WHERE
            subquery_employee.department_id
            = main_query_department.department_id
    ) AS employees_count
FROM departments AS main_query_department

Коррелированный подзапрос может возвращать как простое значение, так и набор значений.
Такие подзапросы запускаются заново для каждой строки основного запроса, и общее время выполнения может быть очень большим.

--- Подзапросы и соединения ---

Задачи, которые мы решали с помощью соединений, иногда можно решить и с помощью подзапросов.

-- Сравниваем соединения и некоррелированные подзапросы --

Иногда мы можем заменить соединение на некоррелированный подзапрос. Одной из таких задач является фильтрация на основе признака, который хранится в связанной таблице. 

Решение с помощью соединения:

SELECT bk.title
FROM books AS bk
INNER JOIN authors AS au
    ON
        bk.book_author_id = au.author_id
WHERE au.author_name = 'А.С. Пушкин';

Решение с помощью подзапроса:

SELECT bk.title
FROM books AS bk
WHERE bk.book_author_id = (
    SELECT au.author_id
    FROM authors AS au
    WHERE au.author_name = 'А.С. Пушкин'
);

Так решение через подзапрос лучше, потому что оно экономичнее. Но и решение через соединение тоже достаточно хорошее. На практике разница между ними может быть минимальной.

-- Сравниваем соединения и коррелированные подзапросы --

Решение с помощью соединения:

SELECT
    bk.title,
    au.author_name
FROM books AS bk
INNER JOIN authors AS au ON
    bk.book_author_id = au.author_id;

Решение с помощью подзапроса:

SELECT
    bk.title,
    (
        SELECT au.author_name
        FROM authors AS au
        WHERE au.author_id = bk.book_author_id
    ) AS author_name
FROM books AS bk

Если строк много, то такой запрос будет работать сильно медленнее запроса с соединением. Поэтому на больших таблицах лучше использовать соединения вместо коррелированных подзапросов.










 


















































