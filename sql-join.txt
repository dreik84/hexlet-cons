Правильно организованные табличные базы хранят данные по правилам нормализации данных. В нормализованном виде информация о разных сущностях хранится в разных таблицах.

---  Несколько таблиц ---

Как правило, таблицы содержат однотипные данные, которые могут относиться к одной сущности. Если добавляется новая сущность, то добавляется новая таблица. Каждая таблица содержит информацию о сущности независимо от других таблиц.

Таблицы не имеют физической связи. Изменение данных в одной таблице, не приводит к изменениям в других. Но таблицы могут быть связаны по смыслу.

-- Связь один ко многим --

Связь "один ко многим" означает, что каждому элементу из одной таблицы соответствует несколько элементов из другой таблицы.

-- Один к одному --

Связь "один к одному" означает, что каждому элементу из одного набора соответствует только один элемент из другой таблицы. 

-- Многие ко многим --

Связь "многие ко многим" (или "много к многим") означает, что несколько элементов из одной таблицы могут соответствовать нескольким элементам из другой таблицы. 

Для представления такой связи часто используется связующая таблица, которая содержит значения обоих наборов элементов.

--- Типы соединения таблиц ---

Соединения — важная часть языка SQL. С помощью соединений мы можем связать строки одной таблицы со строками другой.

В языке SQL есть пять видов инструкции JOIN — типов соединения таблиц:

CROSS JOIN
INNER JOIN
LEFT JOIN или LEFT OUTER JOIN
RIGHT JOIN или RIGHT OUTER JOIN
FULL JOIN или FULL OUTER JOIN

Тип соединения нужно выбирать исходя из того, какой результат мы хотим получить.

-- Соединение без условия --

В эту группу попадает только CROSS JOIN — это соединение строит все возможные комбинации строк из двух таблиц.

SELECT
    color_name,
    material_name
FROM colors
CROSS JOIN materials;

-- Соединения с условием --

В эту группу попадают остальные типы: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN. 
В их случаях в результат попадают не все сочетания, а только те, которые удовлетворяют специальному условию соединения.

-- Выбор типа соединения с условием --

В результат соединения с условием всегда попадают валидные пары строк, то есть удовлетворяющие условию соединения. 
Но конкретный тип соединения выбирают исходя из того, как нужно поступить со строками без пары.

Виды соединений

тип соединения	               валидные пары	строки без пары из TableA	строки без пары из TableB
TableA INNER JOIN TableB	добавляются	  не добавляются	           не добавляются
TableA LEFT JOIN TableB	        добавляются	    добавляются	                   не добавляются
TableA RIGHT JOIN TableB	добавляются	  не добавляются	             добавляются
TableA FULL JOIN TableB	        добавляются	    добавляются                      добавляются

По правилам SQL, строки без пары добавляются в результат всего один раз, а вместо недостающих значений устанавливается NULL.

-- INNER JOIN --

Это соединение отбирает только такие пары строк, которые удовлетворяют специальному условию соединения.

SELECT
    author_name,
    title
FROM books
INNER JOIN authors ON book_author_id = author_id;

-- LEFT JOIN --

LEFT JOIN используют, когда нужно построить соединение, в котором обязательно будут все строки из первой таблицы. 
Если для строки из первой таблицы нет подходящих пар во второй таблице, то вместо данных из второй таблицы будут подставлены NULL-значения.

SELECT
    dep.name AS department,
    emp.name AS employee
FROM departments AS dep
LEFT JOIN employees AS emp ON
    dep.department_id = emp.department_id;

-- RIGHT JOIN --

RIGHT JOIN работает похожим образом, но только в результат попадают все строки из второй таблицы, а не из первой.

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
RIGHT JOIN employees AS emp ON
    dep.department_id = emp.department_id;

-- FULL JOIN --

Полное внешнее соединение используют, когда в результате должны быть все строки из обеих таблиц, даже если у них нет подходящей пары. Результат FULL JOIN включает в себя результаты INNER JOIN, LEFT JOIN и RIGHT JOIN.

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
FULL JOIN employees AS emp ON
    dep.department_id = emp.department_id;

--- CROSS JOIN (перекрестное соединение) ---

Этот тип соединения позволяет получить все возможные сочетания строк из двух таблиц.

SELECT
    color_name,
    material_name
FROM colors -- первая таблица
CROSS JOIN materials; -- вторая таблица

CROSS JOIN соединяет каждую строку из первой таблицы с каждой строкой из второй таблицы. Поэтому число строк в результате — это произведение количества строк из первой таблицы с количеством строк из второй таблицы. 

--- INNER JOIN (внутреннее соединение) ---

Это соединение возвращает сочетания строк из двух таблиц, которые удовлетворяют условию соединения.

SELECT
    author_name,
    title
FROM books -- первая таблица
INNER JOIN authors -- вторая таблица
    ON book_author_id = author_id; -- условие соединения таблиц

Для каждой строки из первой таблицы INNER JOIN пытается найти строки из второй таблицы так, чтобы выполнилось условие соединения. Если во второй таблице будет несколько подходящих строк — в результат попадут все такие пары. Если в первой или во второй таблице есть строки, для которых не нашлась подходящая пара — они не попадут в результат.

--- Псевдонимы (aliases) ---

При работе со сложными запросами легко запутаться, а при работе с соединениями запутаться может даже СУБД. 
Чтобы сделать запросы более понятными и избежать некоторых ошибок компиляции запроса, используют псевдонимы.

-- Неоднозначность запроса и способы ее исправления --

Дело в том, что в таблицах есть столбцы с одинаковыми именами и они используются в нашем запросе, поэтому его нельзя однозначно интерпретировать.

SELECT
    name,
    name -- непонятно, откуда какой столбец надо взять
FROM employees
INNER JOIN departments ON
    department_id = department_id; -- непонятно, откуда какой столбец надо взять

-- Имя таблицы перед именем столбца --

Мы можем добавить имя таблицы перед именем столбца во всех местах, где есть неоднозначность:

SELECT
    employees.name,
    departments.name -- добавили имена таблиц
FROM employees
INNER JOIN departments ON
    employees.department_id = departments.department_id; -- добавили имена таблиц

-- Псевдонимы для таблиц --

Вместо имени таблицы можно использовать собственный псевдоним:

SELECT
    emp.name,
    dep.name
FROM employees AS emp -- объявили псевдоним для employees
INNER JOIN departments AS dep ON -- объявили псевдоним для departments
    emp.department_id = dep.department_id;

Псевдонимы объявляются сразу после имени таблицы в секциях FROM и JOIN с помощью ключевого слова AS. Объявленный псевдоним можно использовать в остальных секциях запроса.

-- Псевдонимы для столбцов --

Еще один вид псевдонимов — это псевдонимы для столбцов:

-- добавили псевдонимы для столбцов
SELECT
    emp.name AS employee,
    dep.name AS department
FROM employees AS emp
INNER JOIN departments AS dep ON
    emp.department_id = dep.department_id;

Псевдонимы для столбцов объявляются в секции SELECT с помощью ключевого слова AS.

Существует несколько ситуаций, когда псевдонимы для столбцов бывают очень полезны.

Во-первых, псевдонимы однозначно определяют имена столбцов в результате запроса. Это полезно, потому что в спорных ситуациях имена столбцам дает СУБД. Но эти имена обычно не очень информативны и разные СУБД назначают их по-разному.

Во-вторых, объявленные псевдонимы столбцов можно использовать в секциях GROUP BY и ORDER BY. Это особенно полезно для вычисляемых столбцов — не нужно дублировать вычисления.

--- INNER JOIN и WHERE ---

С помощью INNER JOIN мы можем связать каждую книгу с ее автором, а оператор WHERE позволяет отфильтровать строки по заданному условию.

SELECT
    authors.author_name,
    books.title
FROM books
INNER JOIN authors
    ON
        books.author_id = authors.author_id -- связываем книги с их авторами
WHERE
    books.language = 'Russian' -- издание на русском языке
    AND authors.origin != 'Russia' -- иностранный автор

Логически СУБД выполняет запрос в следующем порядке:

INNER JOIN — сначала выполняется соединение двух таблиц по условию: books.author_id = authors.author_id
WHERE — затем применяется фильтрация строк с условием: books.language = 'русский' AND authors.origin != 'Россия'
Отбрасываются все столбцы кроме author_name и title

В реальности СУБД может изменить порядок операций, чтобы получить такой же результат, но быстрее.

--- INNER JOIN и GROUP BY ---

Запросы, в которых одновременно используются и соединение, и группировка, часто используются для составления сводных отчетов.
Допустим, мы хотим построить отчет, в котором будет указано название отдела, количество сотрудников в нем и суммарная зарплата всех сотрудников отдела.

SELECT
    dep.name AS department, -- название отдела
    -- количество сотрудников в отделе
    COUNT(emp.employee_id) AS employees_count,
    SUM(emp.salary) AS total_salary -- суммарная зарплата отдела
FROM departments AS dep
INNER JOIN employees AS emp
    ON
        -- связываем сотрудников с отделами
        dep.department_id = emp.department_id
GROUP BY dep.name -- группировка по отделам

Логически СУБД выполняет запрос следующим образом:

Выполняется соединение двух таблиц по условию: dep.department_id = emp.department_id.
Полученные строки разделяются на группы с одинаковым названием отдела — dep.name.
Для каждой группы рассчитываются количество сотрудников в группе — COUNT(emp.employee_id) и суммарная зарплата — SUM(emp.salary).









 


















































