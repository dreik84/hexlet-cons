Правильно организованные табличные базы хранят данные по правилам нормализации данных. В нормализованном виде информация о разных сущностях хранится в разных таблицах.

---  Несколько таблиц ---

Как правило, таблицы содержат однотипные данные, которые могут относиться к одной сущности. Если добавляется новая сущность, то добавляется новая таблица. Каждая таблица содержит информацию о сущности независимо от других таблиц.

Таблицы не имеют физической связи. Изменение данных в одной таблице, не приводит к изменениям в других. Но таблицы могут быть связаны по смыслу.

-- Связь один ко многим --

Связь "один ко многим" означает, что каждому элементу из одной таблицы соответствует несколько элементов из другой таблицы.

-- Один к одному --

Связь "один к одному" означает, что каждому элементу из одного набора соответствует только один элемент из другой таблицы. 

-- Многие ко многим --

Связь "многие ко многим" (или "много к многим") означает, что несколько элементов из одной таблицы могут соответствовать нескольким элементам из другой таблицы. 

Для представления такой связи часто используется связующая таблица, которая содержит значения обоих наборов элементов.

--- Типы соединения таблиц ---

Соединения — важная часть языка SQL. С помощью соединений мы можем связать строки одной таблицы со строками другой.

В языке SQL есть пять видов инструкции JOIN — типов соединения таблиц:

CROSS JOIN
INNER JOIN
LEFT JOIN или LEFT OUTER JOIN
RIGHT JOIN или RIGHT OUTER JOIN
FULL JOIN или FULL OUTER JOIN

Тип соединения нужно выбирать исходя из того, какой результат мы хотим получить.

-- Соединение без условия --

В эту группу попадает только CROSS JOIN — это соединение строит все возможные комбинации строк из двух таблиц.

SELECT
    color_name,
    material_name
FROM colors
CROSS JOIN materials;

-- Соединения с условием --

В эту группу попадают остальные типы: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN. 
В их случаях в результат попадают не все сочетания, а только те, которые удовлетворяют специальному условию соединения.

-- Выбор типа соединения с условием --

В результат соединения с условием всегда попадают валидные пары строк, то есть удовлетворяющие условию соединения. 
Но конкретный тип соединения выбирают исходя из того, как нужно поступить со строками без пары.

Виды соединений

тип соединения	               валидные пары	строки без пары из TableA	строки без пары из TableB
TableA INNER JOIN TableB	добавляются	  не добавляются	           не добавляются
TableA LEFT JOIN TableB	        добавляются	    добавляются	                   не добавляются
TableA RIGHT JOIN TableB	добавляются	  не добавляются	             добавляются
TableA FULL JOIN TableB	        добавляются	    добавляются                      добавляются

По правилам SQL, строки без пары добавляются в результат всего один раз, а вместо недостающих значений устанавливается NULL.

-- INNER JOIN --

Это соединение отбирает только такие пары строк, которые удовлетворяют специальному условию соединения.

SELECT
    author_name,
    title
FROM books
INNER JOIN authors ON book_author_id = author_id;

-- LEFT JOIN --

LEFT JOIN используют, когда нужно построить соединение, в котором обязательно будут все строки из первой таблицы. 
Если для строки из первой таблицы нет подходящих пар во второй таблице, то вместо данных из второй таблицы будут подставлены NULL-значения.

SELECT
    dep.name AS department,
    emp.name AS employee
FROM departments AS dep
LEFT JOIN employees AS emp ON
    dep.department_id = emp.department_id;

-- RIGHT JOIN --

RIGHT JOIN работает похожим образом, но только в результат попадают все строки из второй таблицы, а не из первой.

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
RIGHT JOIN employees AS emp ON
    dep.department_id = emp.department_id;

-- FULL JOIN --

Полное внешнее соединение используют, когда в результате должны быть все строки из обеих таблиц, даже если у них нет подходящей пары. Результат FULL JOIN включает в себя результаты INNER JOIN, LEFT JOIN и RIGHT JOIN.

SELECT
    dep.name as department,
    emp.name as employee
FROM departments AS dep
FULL JOIN employees AS emp ON
    dep.department_id = emp.department_id;


 


















































