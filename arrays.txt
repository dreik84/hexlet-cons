--- О курсе ---

Любые списки, которые окружают нас в реальном или виртуальном мире, являются коллекциями элементов с точки зрения программирования. В Java для их хранения используется массив – структура данных, позволяющая работать с набором как с единым целым.

String[] friends = {"petya", "mila", "ivan"};

В отличие от примитивных типов данных, массивы в Java могут изменяться. Это сильно влияет на работу с ними и добавляет с одной стороны больше возможностей, а с другой – ответственности.

--- Синтаксис ---

Массивы представляют собой последовательность элементов одного типа, например чисел или строк. 

-- Определение массива --

Для создания массива надо знать тип элементов в массиве и имя новой переменной, которая будет ссылаться на массив:

// Массив - ссылочный тип
int[] numbers = {1, 2, 3};
String[] cars = {"kia", "bmw", "ford"};

// Массив может быть даже пустым
int[] fruits = {};

Обратите внимание на именование переменных, содержащих массивы. Они во множественном числе. Это подчеркивает природу переменной и делает код проще для анализа.

Массивы в Java фиксированного размера, поэтому если мы хотим создать пустой массив, но не знаем заранее что должно быть внутри, мы можем создать пустой массив нужной длины и затем заполнить его нужными значениями:

// Это особый синтаксис создания массива, а не объектов по типу
// Обратите внимание на то, что скобки квадратные, а не круглые
int[] numbers = new int[3];
String[] cars = new String[3];
// И так далее для всех остальных типов

-- Вывод на экран --

Массивы относятся к ссылочным типам данных. Обычный способ не работает:

String[] cars = {"kia", "bmw", "ford"};
System.out.println(cars); // => java.lang.String;@27bc2616

Для печати нужно использовать метод Arrays.toString(), который формирует из массива строку. Затем эту строку можно вывести на экран:

import java.util.Arrays;

String[] cars = {"kia", "bmw", "ford"};
System.out.println(Arrays.toString(cars));
// => ["kia", "bmw", "ford"]

-- Получение данных --

Элементы в массиве упорядочены слева направо. Каждый элемент имеет порядковый номер, называемый индексом. Индексация массива начинается с нуля. То есть первый элемент массива доступен по индексу 0, второй — по индексу 1 и так далее. 

String[] animals = {"cats", "dogs", "birds"};
animals[0]; // "cats"
animals[1]; // "dogs"

Узнать размер массива можно, обратившись к его свойству length.

String[] animals = {"cats", "dogs", "birds"};
animals.length; // 3

В реальных задачах индекс часто вычисляется динамически, поэтому обращение к конкретному элементу происходит с использованием переменных:

var i = 1;
var j = 1;
String[] animals = {"cats", "dogs", "birds"};
animals[i + j]; // "birds"

Такой вызов возможен по одной простой причине — внутри скобок ожидается выражение. А там, где ожидается выражение, можно подставлять все, что вычисляется. В том числе вызовы метода.

Довольно часто в задачах с использованием массивов нужно взять последний элемент. Для этого вычисляется последний индекс массива по формуле размер_массива - 1, по которому и можно обратиться к последнему элементу:

String[] animals = {"cats", "dogs", "birds"};
animals[animals.length - 1]; // "birds"


--- Модификация ---

Элементы массива можно изменять, записывая туда другие значения. Синтаксис изменения элемента массива практически такой же, как и при обращении к элементу массива. Разница лишь в наличии присваивания:

String[] animals = { "cats", "dogs", "birds" };
// Меняется первый элемент массива
animals[0] = "horses";

Точно так же можно инициализировать новый массив:

// Создается массив из 5 чисел
int[] numbers = new int[5];

// Порядок заполнения не важен
numbers[1] = 8;
numbers[0] = 3;

Созданный, но не инициализированный массив наполняется значениями по умолчанию. Для каждого типа это свое значение:

boolean : false
int     : 0
double  : 0.0
String  : null

-- Изменение размера массива --

Массивы в Java имеют фиксированную длину. Это связано с тем, как хранятся массивы в памяти. Каждый раз когда нужно изменить размер массива, что-то добавить или удалить, придется создавать новый массив куда копируются нужные значения из старого.














































































