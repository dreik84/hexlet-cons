--- О курсе ---

Любые списки, которые окружают нас в реальном или виртуальном мире, являются коллекциями элементов с точки зрения программирования. В Java для их хранения используется массив – структура данных, позволяющая работать с набором как с единым целым.

String[] friends = {"petya", "mila", "ivan"};

В отличие от примитивных типов данных, массивы в Java могут изменяться. Это сильно влияет на работу с ними и добавляет с одной стороны больше возможностей, а с другой – ответственности.

--- Синтаксис ---

Массивы представляют собой последовательность элементов одного типа, например чисел или строк. 

-- Определение массива --

Для создания массива надо знать тип элементов в массиве и имя новой переменной, которая будет ссылаться на массив:

// Массив - ссылочный тип
int[] numbers = {1, 2, 3};
String[] cars = {"kia", "bmw", "ford"};

// Массив может быть даже пустым
int[] fruits = {};

Обратите внимание на именование переменных, содержащих массивы. Они во множественном числе. Это подчеркивает природу переменной и делает код проще для анализа.

Массивы в Java фиксированного размера, поэтому если мы хотим создать пустой массив, но не знаем заранее что должно быть внутри, мы можем создать пустой массив нужной длины и затем заполнить его нужными значениями:

// Это особый синтаксис создания массива, а не объектов по типу
// Обратите внимание на то, что скобки квадратные, а не круглые
int[] numbers = new int[3];
String[] cars = new String[3];
// И так далее для всех остальных типов

-- Вывод на экран --

Массивы относятся к ссылочным типам данных. Обычный способ не работает:

String[] cars = {"kia", "bmw", "ford"};
System.out.println(cars); // => java.lang.String;@27bc2616

Для печати нужно использовать метод Arrays.toString(), который формирует из массива строку. Затем эту строку можно вывести на экран:

import java.util.Arrays;

String[] cars = {"kia", "bmw", "ford"};
System.out.println(Arrays.toString(cars));
// => ["kia", "bmw", "ford"]

-- Получение данных --

Элементы в массиве упорядочены слева направо. Каждый элемент имеет порядковый номер, называемый индексом. Индексация массива начинается с нуля. То есть первый элемент массива доступен по индексу 0, второй — по индексу 1 и так далее. 

String[] animals = {"cats", "dogs", "birds"};
animals[0]; // "cats"
animals[1]; // "dogs"

Узнать размер массива можно, обратившись к его свойству length.

String[] animals = {"cats", "dogs", "birds"};
animals.length; // 3

В реальных задачах индекс часто вычисляется динамически, поэтому обращение к конкретному элементу происходит с использованием переменных:

var i = 1;
var j = 1;
String[] animals = {"cats", "dogs", "birds"};
animals[i + j]; // "birds"

Такой вызов возможен по одной простой причине — внутри скобок ожидается выражение. А там, где ожидается выражение, можно подставлять все, что вычисляется. В том числе вызовы метода.

Довольно часто в задачах с использованием массивов нужно взять последний элемент. Для этого вычисляется последний индекс массива по формуле размер_массива - 1, по которому и можно обратиться к последнему элементу:

String[] animals = {"cats", "dogs", "birds"};
animals[animals.length - 1]; // "birds"


--- Модификация ---

Элементы массива можно изменять, записывая туда другие значения. Синтаксис изменения элемента массива практически такой же, как и при обращении к элементу массива. Разница лишь в наличии присваивания:

String[] animals = { "cats", "dogs", "birds" };
// Меняется первый элемент массива
animals[0] = "horses";

Точно так же можно инициализировать новый массив:

// Создается массив из 5 чисел
int[] numbers = new int[5];

// Порядок заполнения не важен
numbers[1] = 8;
numbers[0] = 3;

Созданный, но не инициализированный массив наполняется значениями по умолчанию. Для каждого типа это свое значение:

boolean : false
int     : 0
double  : 0.0
String  : null

-- Изменение размера массива --

Массивы в Java имеют фиксированную длину. Это связано с тем, как хранятся массивы в памяти. Каждый раз когда нужно изменить размер массива, что-то добавить или удалить, придется создавать новый массив куда копируются нужные значения из старого.

--- Цикл For ---

Работа с массивами почти всегда завязана на одновременную обработку всех его элементов.  Для перебора элементов массива самый простой способ сделать это – использовать цикл.

-- Обход --

Циклы напрямую с массивами не связаны, но у циклов есть счетчик, который может выступать в качестве индекса массива.

-- Изменение --

Во время обхода массива его можно не только читать, но и модифицировать.

-- Итого --

Цикл for можно комбинировать с массивами в любых вариантах. Массив не обязательно перебирать полностью и от начала до конца. Можно например смотреть только каждый второй элемент или двигаться до половины. Все это зависит от конкретной задачи.

Точно так же массивы сочетаются с while. Единственное что нужно массивам – индекс.

--- Агрегация ---

Распространенный вариант использования циклов с массивами — агрегация. Агрегацией называются любые вычисления, которые, как правило, строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее. 

--- Цикл for-each ---

for относится к низкоуровневым циклам. Он требует задания счетчика, правил его изменения и условия остановки. Было бы значительно удобнее обходить элементы коллекции напрямую, без счетчика. Многие языки программирования решают это введением специального вида цикла. В Java тоже есть такой: for-each.

String[] userNames = {"petya", "vasya", "evgeny"};

for (var name : userNames) {
    System.out.println(name);
}

-- Применимость --

В большинстве задач, использующих цикл, предпочтительнее for-each . Иногда его бывает недостаточно, и требуется ручное управление обходом. В таких случаях можно возвращаться к использованию for.

--- Удаление элементов массива ---

В Java не существует простого способа удалить элемент из массива. Изменение массива трансформируется в создание нового массива, в котором отсутствуют удаляемые элементы.

--- Управляющие инструкции ---

В циклах java доступны для использования две инструкции, влияющие на их поведение: break и continue. Их использование не является необходимым, но все же они встречаются на практике.

-- Break --

Инструкция break производит выход из цикла (Не из метода!). Встретив ее, Java перестает выполнять текущий цикл и переходит к инструкциям, идущими сразу за циклом.

-- Continue --

Инструкция continue позволяет пропустить итерацию цикла.

-- Итого --

break и continue призваны добавить гибкости в управление процессом обхода. На практике же, всегда можно построить код без них и, скорее всего, он будет даже проще. Однако, в реальном коде они встречаются и знать про их существование и поведение нужно.

--- Вложенные массивы ---

Кроме плоских массивов, Java поддерживает вложенные массивы. С их помощью представляют табличные данные, по которым нужно выполнять какие-то вычисления.

// В данном случае массив двухмерный (2D)
int[][] weather = {{14, 15}, {17, 18}, {13, 14}};

// 3 строки и 2 столбца
int[][] weather = new int[3][2];

Вложенность никак не ограничивается. Можно создавать массив массивов массивов и так далее.

int[][][] nested = {{{ 1, 2}, {3, 4}}, {{ 5, 6}, {7, 8}}};

-- Пример использования --

Для чего же могут понадобиться вложенные массивы? Таких примеров довольно много: начиная от математических концепций, например, матриц, заканчивая представлением игровых полей. 

--- StringBuilder ---

Генерация строк в циклах — задача, часто возникающая на практике. Типичный пример — метод, помогающий генерировать HTML-списки. 

class HtmlBuilder {
    public static String buildList(String[] items) {
        var result = "<ul>";
        for (var item : items) {
            result = result + "<li>" + item + "</li>";
        }
        result = result + "</ul>";

        return result;
    }
}

Такой способ вполне рабочий, но для большинства языков программирования максимально неэффективный. Дело в том, что конкатенация порождает новую строчку вместо старой, — и подобная ситуация повторяется на каждой итерации. Причем строка становится все больше и больше. Копирование строк приводит к серьезному расходу памяти и влияет на производительность.

Правильный способ для динамической сборки строк в Java - использование класса StringBuilder. Он позволяет собирать строку по кусочкам без лишнего копирования. Перепишем наш пример:

class HtmlBuilder {
    public static String buildList(String[] items) {
        // Инициализируем с начальной строкой "<ul>"
        var result = new StringBuilder();
        result.append("<ul>");
        // Или можно сразу
        // var result = new StringBuilder("<ul>");
        for (var item : items) {
            // append дополняет строку
            result.append("<li>");
            result.append(item);
            result.append("</li>");
        }
        result.append("</ul>");

        // toString собирает все части в одну строку
        return result.toString();
    }
}

Размер кода практически не изменился, но способ формирования результата стал другим. Вместо перезаписи строки, создается объект, который "накапливает" внутри себя части новой строки. Затем этот объект превращается в строку с помощью метода toString().

--- Обработка строк через преобразование в массив ---

Дана строка текста. Нужно сделать заглавной первую букву каждого слова в тексте. Для простоты считаем что мы работаем с текстом, который не содержит знаков препинания.

Решить ее можно многими способами. Чем больше называет человек — тем лучше. Разберем решение через массив. Для этого воспользуемся методом строки split(), который разделяет строку на массив используя указанный разделитель.

У этой задачи есть и другое решение, с помощью класса StringJoiner. Этот класс работает как StringBuilder, но дополнительно позволяет указывать соединитель:

import org.apache.commons.lang3.StringUtils;

class MyStringUtils {
    public static String capitalizeWords(String sentence) {
        // split разделяет строку по пробелу
        var words = sentence.split(" ");
        // Указываем соединитель
        var result = new StringJoiner(" ");
        for (var word : words) {
            // Приводим первую букву слова к верхнему регистру
            // Добавляем полученное слово в StringJoiner при помощи метода add()
            result.add(StringUtils.capitalize(word));
        }
        // Соединяет части строки используя соединитель
        return result.toString();
    }
}

--- Вложенные циклы ---

Чисто технически во вложенных циклах нет ничего особенного. Их можно вкладывать внутрь любого блока и друг в друга сколько угодно раз. Но прямой связи между внешним и вложенным циклами нет. Внутренний цикл может использовать результаты внешнего, а может и работать по своей собственной логике независимо.

Вложенные циклы коварны. Их наличие может резко увеличить сложность кода, так как появляется множество постоянно изменяющихся переменных. Становится тяжело уследить за происходящими внутри процессами.

Как избавиться от вложенных циклов? Есть три варианта: 
Первый – ничего не делать, иногда вложенные циклы это нормально, особенно в низкоуровневых алгоритмах. 
Второй – переписать алгоритм так, чтобы вложенного цикла не осталось вообще, даже в вызываемых методах. 
Когда это невозможно – использовать третий вариант. Вынести вложенный цикл в отдельный метод, либо заменить на уже готовый метод. Например, в библиотеке Apache Commons Lang есть метод ArrayUtils.contains(), который внутри себя представляет не что иное, как обход массива в цикле.

---  Теория множеств ---

Теория множеств – крайне важная математическая концепция для любых разработчиков. Данные, с которыми работают программы, часто представляются как множества, а значит к ним применимы правила теории множеств. В первую очередь это касается различных операций над множествами, например, пересечения или объединения.

-- Краткая терминология --

Множеством обозначают набор объектов произвольной природы, рассматривающихся как единое целое. Простейший пример — цифры. Множество всех цифр включает в себя 10 элементов (от 0 до 9).

Но не каждый набор объектов можно назвать множеством. Существует важное условие – все элементы множества должны быть уникальными. Например, числа 1, 1 и 3 не могут называться множеством, а 1, 3, 5 могут.

Множества между собой могут находиться в определенных отношениях. Например, множество натуральных чисел является подмножеством целых чисел, которые в свою очередь являются подмножеством рациональных чисел и так далее. Понятие «подмножество» означает, что все элементы одного множества также входят в другое множество, называемое надмножеством.

-- Операции над множествами --

На практике, представление данных в виде множеств полезно тогда, когда мы хотим что-то сделать с ними. Простой пример. Когда в Фейсбуке вы заходите на страницу другого человека, то Фейсбук показывает вам блок с общими друзьями. Если принять, что ваши друзья и друзья вашего друга — два множества, то общие друзья — множество, полученное как пересечение исходных множеств друзей.

-- Пересечение --

Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.

// Друзья одного человека
String[] friends1 = {"vasya", "kolya", "petya"};

// Друзья другого человека
String[] friends2 = {"igor", "petya", "sergey", "vasya", "sasha"};

// Общие друзья
ArraysAsSets.intersection(friends1, friends2);
// ["vasya", "petya"]

-- Объединение --

Объединением множеств называется множество, в которое входят элементы всех данных множеств.

String[] friends1 = {"vasya", "kolya", "petya"};
String[] friends2 = {"igor", "petya", "sergey", "vasya", "sasha"};

ArraysAsSets.union(friends1, friends2);
// ["vasya", "kolya", "petya", "igor", "sergey", "sasha"]

-- Дополнение (разность) --

Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе. В программировании такая операция часто называется diff (разница).

String[] friends1 = {"vasya", "kolya", "petya"};
String[] friends2 = {"igor", "petya", "sergey", "vasya", "sasha"};

ArraysAsSets.difference(friends1, friends2);
// ["kolya"]

--- Сортировка массивов ---

Сортировка массивов — базовая алгоритмическая задача, которую нередко спрашивают на собеседованиях. Однако в реальном коде массивы сортируют, используя уже готовые методы стандартной библиотеки. В java сортировка выполняется с помощью метода java.util.Arrays.sort().

Знание алгоритмов действительно влияет на то, как мы думаем и насколько быстро соображаем. И хотя невозможно знать все алгоритмы, нужно хотя бы иметь представление о самых ключевых и в идеале уметь их реализовывать. 

Роберт Мартин рекомендует время от времени решать классические алгоритмические задачки для поддержания формы. Эта тема стала настолько популярной, что если загуглить java github kata, то вы увидите множество репозиториев с подобными задачками.

-- Сортировка --

Способов сортировать массив достаточно много. Самый популярный для обучения — пузырьковая сортировка (bubble sort).
Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. 

https://visualgo.net/en/sorting?slide=1

--- Big O ---

Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» (обозначается как Big O). Оно дает понимание того, насколько эффективен алгоритм.

Как вы помните, алгоритмов сортировок существует много. Все они выполняют одну и ту же задачу, но при этом отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели.

Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.
Вот некоторые примеры того, как записывается сложность: O(1), O(n), O(nlog(n))

O(1) описывает константную (постоянную) сложность. Такой сложностью обладает операция доступа к элементу массива по индексу. Сложность (в алгоритмическом смысле) доступа к элементу не зависит от размеров массива и является величиной постоянной.

 А вот функция, которая печатает на экран все элементы переданного массива, используя обычный перебор, имеет сложность O(n) (линейная сложность). То есть количество выполняемых операций, в худшем случае, будет равно количеству элементов массива. Именно это количество символизирует символ n в скобках.

Что такое худший случай? В зависимости от того в каком состоянии находятся начальный массив, количество операций будет разным даже при условии, что массив одного и того же размера.
Алгоритмическая сложность всегда оценивается по худшему случаю для выбранного алгоритма.

Еще один пример — вложенные циклы. Вспомните как работает поиск пересечений в неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент другого массива (либо через цикл, либо с помощью метода includes(), чья сложность O(n), ведь в худшем случае он просматривает весь массив). Если принять, что размеры обоих массивов одинаковы и равны n, то получается, что поиск пересечений имеет квадратичную сложность или O(n^2) (n в квадрате).

Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют больше памяти или имеют возможность запускаться параллельно (и если это происходит, то работают крайне эффективно). Как и все в инженерной деятельности, эффективность — компромисс. Выигрывая в одном месте, мы проиграем где-то в другом.

Big O, во многом, теоретическая оценка, на практике все может быть по-другому. Реальное время выполнения зависит от множества факторов среди которых: архитектура процессора, операционная система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.

Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это главное. Код должен быть быстрым.

Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или вообще не нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. 

https://optimization.guide/

--- Реализация массивов ---

Массив представляется цельным куском памяти, размер которого вычисляется по формуле «количество элементов» * «количество памяти под каждый элемент». 
Из этого утверждения есть два интересных вывода:
- Размер массива — это фиксированная величина. Те динамические массивы, с которыми мы имеем дело, во многих языках реализованы уже внутри языка, а не на уровне железа
- Все элементы массива имеют один тип и занимают одно и то же количество памяти. 

Фактически, индекс в массиве — смещение относительно начала куска памяти, содержащего данные массива. Адрес, по которому расположен элемент под конкретным индексом, рассчитывается так: начальный адрес + индекс * количество памяти, занимаемое одним элементом:

// Инициализация массива из пяти элементов типа int
// int занимает 4 байта
// Общее количество памяти выделенное под массив int * 5 = 4 * 5 = 20 байт
int[] numbers = {19, 10, 8, 17, 9};
numbers[3]; // 17

Адрес элемента, соответствующего индексу 3, вычисляется так: начальный адрес + 3 * 4 (размер типа данных int). Начальный адрес — это адрес ячейки памяти, начиная с которой располагается массив. Он формируется во время выделения памяти под массив. 





























































