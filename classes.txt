--- Создание собственных типов ---

Java – язык, который сильно ориентирован на классы. Практически для любой задачи нужно создавать классы, особенно той, которая связана с данными.
Когда говорят про классы, обычно говорят про предметную область, например, если взять Хекслет, это будет онлайн-обучение. В этой области есть такие понятия как курс, группа, ученик, проект, задание, квиз и многое другое. В коде все эти понятия представлены классами со своими наборами свойств и методов.

class Lesson {
    private Course course;
    private String name;
}

Это важная часть приложения для которой используются классы, но далеко не единственная. Подавляющее большинство классов в приложениях относятся к другим категориям. 

-- Исключения --

Ошибки в Java тоже представлены классами. Для каждого типа ошибки создаются свои классы. Обычно это делается в библиотеках или встроено в саму Java, но бывает, что приходится создавать подобные классы для ошибок и в прикладном коде.

-- Data-классы --

Категория, в которую попадают объекты для хранения или передачи данных куда-то дальше.
В Java объекты таких классов называют Data Transfer Object (DTO).

public class PostDTO {
    private Long id;
    private Long authorId;
}

Главная особенность data-классов в том, что они не содержат никакого поведения, это просто хранилище данных для постоянного, как в случае конфигурации, или DTO для временного использования.

-- Сервисы --

Это классы, объекты которых, используются для выполнения однотипных задач вокруг какого-то сервиса или механизма. Например, у нас может быть сервис для отправки писем или sms.
Часто сервисы строятся вокруг каких-то внешних систем, например PayPal, для работы с платежами.

-- Служебные объекты --

Большая и разнообразная категория, в которую, например, входят классы для взаимодействия с другими программами, такими как базы данных, очереди, кеши и многое другое.

-- Утилиты --

Какие-то вспомогательные объекты для решения разнообразных задач, например, обработки строк, преобразования Markdown в HTML и тому подобное. Утилиты почти всегда похожи на обычные функции из других языков программирования.

-- Остальное --

Есть немало и других классов, которые не попали ни под одну из категорий выше. Со всем этим многообразием вы будете знакомиться не только во время обучения, но и уже в реальной работе, причем постоянно.

---  Класс Объект ---

Наследование это механизм связи между классами, когда один класс, называемый наследуемым (дочерним, подклассом), как бы расширяет другой класс, называемый базовым (родительским, суперклассом). Выглядит это так:

class Expert extends User {

}

Наследование никак не влияет на родительский класс, но значительно влияет на класс наследник. Он наследует все, что реализовано в родительском классе. 

-- Object --

Если мы создадим объект любого класса, в котором не определен ни один метод, то увидим, что у него уже доступны какие-то методы, например, toString(). Откуда берутся эти методы если мы ничего не определили? Дело в том, что любой класс в Java неявно наследует класс Object. Это делает его суперклассом для всех Java-классов.

var name = "hexlet";
System.out.println(name); // => hexlet
System.out.println(name.toString()); // => hexlet

var user = new User();
System.out.println(user); // => io.hexlet.User@25618e91
System.out.println(user.toString()); // => io.hexlet.User@25618e91

Для строк этот метод возвращает саму строку, что логично. А вот для других объектов toString() возвращает стандартное представление, состоящее из имени класса и хеша. Но если мы хотим, то можем легко изменить это поведение, реализовав метод toString() внутри нашего класса. Таким образом мы переопределим метод родительского класса.

// Если метод переопределяется, то добавляют аннотацию @Override
    @Override
    public String toString() {
        return "User [name=" + name + "]";
    }

В этом примере метод отмечен аннотацией @Override. Она явно указывает, что метод переопределяет метод родительского класса. 

-- Приведение типов --

Другая важная деталь в наличии Object связана с приведением типов. Любой объект можно представить как объект типа Object.

// Будут работать только методы описанные в Object
Object obj = new User("Nina");

Такое поведение полезно в следующих сценариях:
1.Когда мы хотим иметь возможность обрабатывать объекты всех типов каким-то одинаковым способом. Например, метод System.out.println() работает именно так. Его параметр имеет тип Object: println(Object x).
2.Для хранения объектов разных типов в рамках одной структуры. С этим примером мы познакомимся ближе в курсе по дженерикам, где реализуем свою коллекцию элементов, работающую со всеми типами.

--- Сравнение объектов ---

Прямое сравнение объектов в Java почти всегда (кроме строк) будет возвращать false для разных объектов, даже если их содержимое идентично:

var u1 = new User("Mike");
var u2 = new User("Anna");
u1 == u2; // false

Иногда необходимо другое поведение, например, сравнение на основе каких-то значений. 

-- equals() --

Эта задача тесно связана с классом Object. Именно в нем реализован механизм, который мы используем для сравнения строк.

str1.equals(str2);

В случае строк equals() сравнивает сами строки. Для всех остальных типов объектов, стандартная реализация возвращает true только в том случае, если объект сравнивается сам с собой. 
Но это поведение можно изменить так как нам нужно, благодаря возможности переопределить этот метод в нужном классе. 

@Override
    public boolean equals(Object obj) {
        // Если объект сравнивается сам с собой
        if (this == obj) {
            return true;
        }

        // Проверяем что объект того же класса
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }

        // Приводим тип к нужному, в данном случае User
        User person = (User) obj;

        // Сравниваем нужные поля
        return firstName.equals(person.firstName) && age == person.age;
    }

Большая часть этого кода идентична для всех классов. Разница появляется только в самом конце, где мы выбираем по каким полям происходит сравнение и то как это делается.

-- hashCode() --

Переопределение equals() при сравнении объектов, важное условие работы этой системы, но недостаточное. Этот метод работает в связке с методом hashCode(), который нужно переопределять тогда, когда переопределяется equals(). Почему? hashCode() возвращает числовой хеш-код, используемый в коллекциях для хранения объектов. Этот код должен быть одинаковым у объектов, считающихся одинаковыми с точки зрения метода equals(). Подробнее мы с этим столкнемся тогда, когда начнем изучать коллекции.

Для класса User, объекты которого сравниваются на основе firstName и age его реализация может быть такой:

@Override
public int hashCode() {
    return Objects.hash(firstName, age);
}

Статический метод Objects.hash() возвращает уникальный (с оговорками) числовой код для всех переданных в него параметров. То есть ровно то, что требуется от метода hashCode().

-- Вывод --

Сравнение объектов в Java реализуется с помощью методов equals() и hashCode(). Основные правила при работе с equals() и hashCode() звучат так:

- Если переопределяется equals(), то должен переопределяться hashCode().
- Одинаковые объекты должны возвращать одинаковый хеш-код.
- Разные объекты могут возвращать одинаковый хеш-код.

--- Lombok ---

В Java разработчики часто сталкиваются с необходимостью написания повторяющегося шаблонного кода. К таким элементам относятся конструкторы, геттеры и сеттеры. Это может приводить к значительному увеличению объема кода, особенно в больших проектах.

-- Решение с Lombok --

Lombok – это библиотека, которая позволяет убрать шаблонный код при создании классов.

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor

Во время исполнения этот код будет заменен на обычный класс Java со всеми нужными методами.
То, что мы здесь видим, называется аннотациями. Аннотации в Java это тоже код. Они начинаются с символа @ за которым идет имя аннотации. Аннотации могут сопровождаться параметрами в стиле, похожем на вызов функций.

@Annotation(key=value)

Сами по себе аннотации на код никак не влияют. Аннотации лишь добавляют информацию к классу, которую затем может прочитать и использовать другой код. В нашем случае это будет делать плагин Lombok для Gradle.
Lombok встраивается в процесс компиляции, во время которой он "наполняет" классы необходимыми методами.

За что отвечает каждая аннотация выше?

@Getter: Генерирует стандартные геттеры для всех полей класса.
@Setter: Генерирует стандартные сеттеры для всех полей класса.
@NoArgsConstructor: Генерирует пустой конструктор. Используется только тогда, когда определен хотя бы один не пустой конструктор.
@AllArgsConstructor: Генерирует конструктор со всеми полями. Поля в конструкторе перечислены в том же порядке, в котором они определены в классе.

-- @ToString --

@toString еще одна полезная аннотация, которая генерирует метод toString() добавляя в него все не статические поля класса.

-- @EqualsAndHashCode --

Аннотация @EqualsAndHashCode генерирует методы equals() и hashCode() соответственно. По умолчанию, в эти методы включаются все не статические поля класса. 
Если поведение необходимо изменить, то @EqualsAndHashCode позволяет это сделать описав те поля, которые нужно явно включить или исключить.

--- Data-классы ---

Для получения данных извне и передачи их куда-то дальше в Java используются Data-классы. Обычно это связано с любыми внешними источниками данных, базой данных, HTTP, файлами.
Data-классы это обычные классы без поведения. Из-за этого их стараются делать неизменяемыми, или как говорят иммутабельными (immutable), для избежания случайных ошибок. В идеале у этих классов нет сеттеров, а все поля помечены как final, что защищает их от изменения.

Data-классы это настолько большая часть любого приложения на Java, что в язык была внедрена новая конструкция Record (запись). Записи по своей сути Data-классы. 

public record OrderDTO(int id, String customerName, double orderAmount) {
}

Запись значительно сокращает количество кода, предоставляя практически такую же функциональность. Но с небольшими отличиями. Геттеры в записях не содержат префикса get.
Несмотря на синтаксическое превосходство, записи обладают рядом недостатков, которые делают их использование в качестве замены обычных классов неудобным. Сюда входят:

- Возможность работать только в неизменяемом стиле. Нет сеттеров.
- Только один конструктор со всеми полями.
- Нет наследования (иногда нужно).
- Многие библиотеки и фреймворки до сих пор не совместимы с записями.

Поэтому основным способом по-прежнему является создание обычных классов. И Lombok делает этот процесс достаточно простым.

@Getter
@AllArgsConstructor
public class OrderDTO {
    private final int id;
    private final String customerName;
    private final double orderAmount;
}



































