--- Создание собственных типов ---

Java – язык, который сильно ориентирован на классы. Практически для любой задачи нужно создавать классы, особенно той, которая связана с данными.
Когда говорят про классы, обычно говорят про предметную область, например, если взять Хекслет, это будет онлайн-обучение. В этой области есть такие понятия как курс, группа, ученик, проект, задание, квиз и многое другое. В коде все эти понятия представлены классами со своими наборами свойств и методов.

class Lesson {
    private Course course;
    private String name;
}

Это важная часть приложения для которой используются классы, но далеко не единственная. Подавляющее большинство классов в приложениях относятся к другим категориям. 

-- Исключения --

Ошибки в Java тоже представлены классами. Для каждого типа ошибки создаются свои классы. Обычно это делается в библиотеках или встроено в саму Java, но бывает, что приходится создавать подобные классы для ошибок и в прикладном коде.

-- Data-классы --

Категория, в которую попадают объекты для хранения или передачи данных куда-то дальше.
В Java объекты таких классов называют Data Transfer Object (DTO).

public class PostDTO {
    private Long id;
    private Long authorId;
}

Главная особенность data-классов в том, что они не содержат никакого поведения, это просто хранилище данных для постоянного, как в случае конфигурации, или DTO для временного использования.

-- Сервисы --

Это классы, объекты которых, используются для выполнения однотипных задач вокруг какого-то сервиса или механизма. Например, у нас может быть сервис для отправки писем или sms.
Часто сервисы строятся вокруг каких-то внешних систем, например PayPal, для работы с платежами.

-- Служебные объекты --

Большая и разнообразная категория, в которую, например, входят классы для взаимодействия с другими программами, такими как базы данных, очереди, кеши и многое другое.

-- Утилиты --

Какие-то вспомогательные объекты для решения разнообразных задач, например, обработки строк, преобразования Markdown в HTML и тому подобное. Утилиты почти всегда похожи на обычные функции из других языков программирования.

-- Остальное --

Есть немало и других классов, которые не попали ни под одну из категорий выше. Со всем этим многообразием вы будете знакомиться не только во время обучения, но и уже в реальной работе, причем постоянно.

---  Класс Объект ---

Наследование это механизм связи между классами, когда один класс, называемый наследуемым (дочерним, подклассом), как бы расширяет другой класс, называемый базовым (родительским, суперклассом). Выглядит это так:

class Expert extends User {

}

Наследование никак не влияет на родительский класс, но значительно влияет на класс наследник. Он наследует все, что реализовано в родительском классе. 

-- Object --

Если мы создадим объект любого класса, в котором не определен ни один метод, то увидим, что у него уже доступны какие-то методы, например, toString(). Откуда берутся эти методы если мы ничего не определили? Дело в том, что любой класс в Java неявно наследует класс Object. Это делает его суперклассом для всех Java-классов.

var name = "hexlet";
System.out.println(name); // => hexlet
System.out.println(name.toString()); // => hexlet

var user = new User();
System.out.println(user); // => io.hexlet.User@25618e91
System.out.println(user.toString()); // => io.hexlet.User@25618e91

Для строк этот метод возвращает саму строку, что логично. А вот для других объектов toString() возвращает стандартное представление, состоящее из имени класса и хеша. Но если мы хотим, то можем легко изменить это поведение, реализовав метод toString() внутри нашего класса. Таким образом мы переопределим метод родительского класса.

// Если метод переопределяется, то добавляют аннотацию @Override
    @Override
    public String toString() {
        return "User [name=" + name + "]";
    }

В этом примере метод отмечен аннотацией @Override. Она явно указывает, что метод переопределяет метод родительского класса. 

-- Приведение типов --

Другая важная деталь в наличии Object связана с приведением типов. Любой объект можно представить как объект типа Object.

// Будут работать только методы описанные в Object
Object obj = new User("Nina");

Такое поведение полезно в следующих сценариях:
1.Когда мы хотим иметь возможность обрабатывать объекты всех типов каким-то одинаковым способом. Например, метод System.out.println() работает именно так. Его параметр имеет тип Object: println(Object x).
2.Для хранения объектов разных типов в рамках одной структуры. С этим примером мы познакомимся ближе в курсе по дженерикам, где реализуем свою коллекцию элементов, работающую со всеми типами.
















































