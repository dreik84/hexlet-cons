--- Реляционные базы данных ---

Для удобной работы с данными существуют специальные программы — они называются СУБД (системы управления базами данных).

-- Сложность СУБД --

Программы Postgresql, Mysql, Oracle, SQL Server являются СУБД — Системой Управления Базами Данных. СУБД не то же самое, что и база данных (БД). 
БД — это хранилище данных, у которых определенная внутренняя структура. Но кто-то должен ее обслуживать: создавать, обновлять, записывать в нее данные, выбирать их. 
Именно этим и занимается СУБД — специальная программа, которую необходимо установить на ту машину, где планируется размещать базу данных.
СУБД — невероятно сложные программы, к которым предъявляются практически максимальные требования по надежности, скорости работы и эффективности. 

-- Как устроены СУБД --

СУБД реализуется как клиент-серверное приложение:
- Сервером выступает сама СУБД — она управляет файлами баз данных, принимает запросы от клиентов и выполняет их команды.
- Клиентом считается любое приложение, желающее взаимодействовать с базой данных.

Сервер в такой архитектуре спроектирован так, что он может работать с большим количеством одновременных подключений от разных клиентов. 
Как правило, база данных используется большим количеством пользователей одновременно.

--- Структура баз данных ---

Таблицы состоят из строк (записей) и столбцов (полей), для которых заданы типы данных. Каждая строка отражает информацию об одном объекте.

-- Таблицы в базах данных --

Чтобы всем было удобно работать с такими объемами данных, к таблицам предъявляются конкретные требования:
- Название таблицы. Оно должно быть уникально в рамках одной базы данных. Название таблицы мы задаем при создании, но его можно изменить при необходимости
- Столбцы или поля. У каждого поля уникальное имя в рамках одной таблицы
- Тип данных столбца. Он ограничивает набор допустимых значений, которые можно присвоить столбцу. Например, в столбец числового типа нельзя записать текстовые строки.
- Строки или записи. Их количество в разных таблицах сильно отличается — от нескольких штук до миллиардов записей. В базах данных нет никаких гарантий относительно порядка строк в таблице.

Базы данных, в которых данные хранятся в виде таких таблиц, называются реляционными базами данных. Название "реляционные" происходит от слова "relation" (отношение) в математической теории множеств. В реляционных базах данных таблицы представляют собой отношения, где строки — это экземпляры данных, а столбцы — свойства (атрибуты) этих данных. Работать с ними можно с помощью реляционных СУБД.

-- Структура таблиц --

Каждая таблица должна иметь определенную структуру. Эта структура определяет столбцы и включает в себя имена полей и их типы.

-- Как правильно именовать сущности --

Именование таблиц и полей зависит от программиста и определяется соглашениями конкретной группы разработчиков:
- Задаем все имена в нижнем регистре
- Для имен из нескольких слов используем snake_case (разделяем слова подчеркиванием _ без пробелов)
- Называем таблицы по хранимым сущностям во множественном числе (например, в таблице с именем users должна храниться информация о пользователях)

-- Как управлять данными --

Для управления данными и их структурой существует специальный инструмент — язык SQL. 
Это универсальный язык, позволяющий работать с разными СУБД. 

--- Язык SQL ---

SQL (Structured Query Language) — это язык, который помогает управлять данными в СУБД.

SQL — это декларативный язык программирования. Он описывает, что нужно получить, не объясняя, как именно нужно прийти к такому результату.

SQL позволяет:
- Управлять данными внутри таблицы — добавлять их, редактировать, выбирать.
- Менять структуру самих таблиц и баз данных.

Язык SQL разрабатывается независимо от СУБД и имеет собственный стандарт, который реализуют конкретные базы данных. Поэтому на базовом уровне все реляционные базы данных работают примерно одинаково.

-- Создание базы данных --

Чтобы начать работать с базой данных, ее нужно создать. Чтобы это сделать, нужно установить СУБД на специальный компьютер — сервер.

CREATE DATABASE hexlet_db;

-- Как создать таблицу --

CREATE TABLE users (
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(255),
    created_at TIMESTAMP
);

-- Как добавить запись --

INSERT INTO users
(first_name,  last_name, email, created_at)
VALUES ('Maureen', 'Romaguera',  'Casimer_Cronin@yahoo.com', '2022-06-14 02:28:26.058');

-- -- Как обновить запись --

UPDATE users SET email = 'Casimer_Cronin@gmail.com'
WHERE last_name = 'Romaguera';

-- Как удалить запись --

DELETE FROM users WHERE last_name = 'Romaguera';

-- Как выбрать запись --

SELECT * FROM users WHERE first_name = 'Ramiro';

-- Удаление таблиц --

DROP TABLE users;

-- Комментарии в запросах --

Комментарии в SQL позволяют вам добавлять пояснения и заметки к вашему запросу. При этом сами они не являются частью запроса, не влияют его выполнение и игнорируются интерпретатором.

В SQL существует два основных вида комментариев: однострочные и многострочные

-- однострочный комментарий

/*
многострочный
комметарий
*/

--- Подключение к БД с помощью psql ---

SQL - это структурированный язык запросов. 

Psql - это интерактивная консольная утилита, которая позволяет взаимодействовать с базой данных через командную строку. 
Клиент psql это стандартный способ для подключения к БД и его можно установить вместе с СУБД.

Для начала, чтобы подключиться к базе данных с помощью psql, необходимо выполнить команду:

psql -h server_address -U username -d dbname

Где server_address - адрес сервера СУБД, username - это ваше имя пользователя, а dbname - название базы данных, к которой вы хотите подключиться. После выполнения этой команды вам будет предложено ввести пароль.

psql -h 65.108.223.44 -d coursesdb -U student
Password for user student:
# вводим пароль student

После успешного подключения, вы увидите приглашение psql для ввода команд и название текущей базы данных. 

-- Работа с SQL --

coursesdb=> SELECT id, first_name, last_name FROM users ORDER BY first_name ASC LIMIT 5;

Чтобы запрос выполнился, нужно соблюсти два условия:
- В конце запроса должна быть точка с запятой ;
- В конце запроса необходимо нажать kbd:[Enter] для его отправки.

-- Клиент DBeaver --

DBeaver - бесплатный универсальный клиент для работы с различными СУБД. 
Он позволяют работать с базами данных через графический интерфейс и имеют те же возможности, что и psql.

---  Таблицы ---

К таблицам предъявляется требование о типе данных поля или столбца. Тип данных накладывает ограничение на то, какие данные могут содержаться в столбце и какие операции можно с ними совершать.

-- Типы данных --

У каждого поля в PostgreSQL определенный тип, который задается на этапе создания таблицы. Это значит, что значением этого поля могут быть только определенные данные.

- Строки -

Для строк в базах данных в основном используются два типа:

varchar - для строк с ограничением максимальной длины (character varying)
text - для строк без ограничения. Как правило, это полноценные тексты

Пример создания таблицы с такими типами:

CREATE TABLE topics (
    title varchar(255),
    body text
);

Для строк в SQL используют одинарные кавычки:

INSERT INTO topics (body, title) VALUES ('Architecto id autem modi.', 'est iste corporis');

- Числа -

Для чисел в основном используются два типа данных: integer и bigint. Какой конкретно указывать тип, зависит от потенциального потолка значения. 

integer	типичный выбор для целых чисел	-2147483648 .. +2147483647
bigint	целое в большом диапазоне	-9223372036854775808 .. 9223372036854775807
real	вещественное число      	-2147483648 .. +2147483647, точность в пределах 6 десятичных цифр

Пример создания таблицы с такими типами:

CREATE TABLE users (
    id          bigint,
    age         integer,
    weight      real
);

INSERT INTO users (id, age, weight) VALUES (1, 38, 67.4);

- Даты -

Типы для хранения дат отличаются друг от друга очень сильно, в первую очередь по решаемой задаче. 
Если нам надо хранить день без конкретного времени? Это тип date. Нужно конкретный момент времени, тогда timestamp. Просто время без даты? Тогда time.

timestamp	дата и время (без часового пояса)	4713 до н. э.	294276 н. э.	1 микросекунда
date	        дата (без времени суток)	        4713 до н. э.	5874897 н. э.	1 день
time	        время суток (без даты)	00:00:00	24:00:00	                1 микросекунда

Пример создания таблицы с такими типами:

CREATE TABLE users (
    id bigint,
    username VARCHAR(50),
    birthday DATE,
    updated_at TIMESTAMP,
    created_at TIMESTAMP
);

INSERT INTO users (id, username, birthday, created_at, updated_at) VALUES (1, 'Duncan3', '2022-05-25', '2022-06-14 18:31:05.296', '2022-06-14 18:31:05.296'); 

Хорошей практикой считается добавление и заполнение полей created_at и updated_at в каждую таблицу базы данных. С их помощью всегда можно узнать, когда запись создалась и обновилась.

- Логический тип -

Содержит всего два значения: true и false. Этот тип используется для флагов:

boolean	true или false (истина или ложь)

Пример создания таблицы с такими типами:

CREATE TABLE users (
    id bigint,
    username VARCHAR(50),
    email_confirmed BOOLEAN,
    email VARCHAR(255)
);

INSERT INTO users (id, username, email, email_confirmed) VALUES (1, 'Duncan3', 'duncan3@example.com', TRUE);

Состояние «true» может задаваться следующими значениями: TRUE, 't', 'true', 'y', 'yes', 'on', '1'
Состояние «false» может задаваться следующими значениями: FALSE, 'f', 'false', 'n', 'no', 'off', '0'

- NULL -

Помимо типов данных для реальных значений, в базе существует специальное значение NULL, чтобы обозначать пустоту. Оно используется, когда у конкретного поля нет значения. Тип поля при этом не важен. 

CREATE TABLE topics (
   user_id integer,
   body text
);

INSERT INTO topics (user_id, body) VALUES
(1, 'Классный курс!'),
(2, NULL);

--- Первичный ключ и автоинкремент ---

Первичный ключ однозначно идентифицирует каждую запись внутри таблицы. 
Задается с помощью фразы PRIMARY KEY, которая добавляется после указания типа, когда создается таблица. 
Первичный ключ в таблице может быть только один, и для него используется отдельное поле - идентификатор.

CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(255),
    created_at TIMESTAMP
);

-- Автогенерация первичного ключа --

Первичный ключ в базах данных принято заполнять автоматически, используя встроенные в базу данных возможности. 
Автогенерацию первичного ключа часто называют автоинкрементом (autoincrement).
Такой автоинкремент создается с помощью GENERATED ALWAYS AS IDENTITY

Основной ключ и автоинкремент часто используются вместе:

CREATE TABLE users (
    -- Одновременное использование и первичного ключа и автогенерации
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    username VARCHAR(50),
    email VARCHAR(255),
    created_at TIMESTAMP
);

Автогенерация не связана с данными в таблице. Это отдельный счетчик, который всегда увеличивается. Так избегаются вероятные коллизии и ошибки, когда один и тот же идентификатор принадлежит сначала одной записи, а потом другой.

Вот его сигнатура из документации:

column_name type GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY[ ( sequence_option ) ]

Тип данных может быть SMALLINT, INT или BIGINT
GENERATED ALWAYS -- не позволит добавлять значение самостоятельно, используя UPDATE или INSERT
GENERATED BY DEFAULT -- в отличие от предыдущего варианта, этот вариант позволяет добавлять значения самостоятельно

PostgreSQL позволяет иметь более одного автогенерируемого поля на таблицу.

--- Запросы на выборку ---

SELECT одна из самых часто используемых операций SQL. С помощью этой команды выполняют выборку данных из таблиц.

SELECT * FROM users;
SELECT username, email FROM users;

Обратим внимание на оформление запросов:
- Все запросы оканчиваются символом ;
- Все названия полей и таблиц пишем строчными буквами, а ключевые слова и операторы языка — заглавными: SELECT, FROM.

Вообще говоря, СУБД не зависит от регистра. Но читать такой запрос очень сложно: не совсем понятно, где названия полей, а где — таблица, из которой выбираются данные.

--- Фильтрация данных ---

В языке SQL для того, чтобы отобрать записи по требуемому условию, используют оператор WHERE.

SELECT * FROM users WHERE id > 60;

В условиях мы можем использовать и другие операторы сравнения:

=   — равно
!=  — не равно
>   — больше
<   — меньше
>=  — больше либо равно, не меньше
\<= — меньше либо равно, не больше

Текст в SQL должен записываться в одинарных кавычках:

SELECT * FROM users WHERE first_name = 'Johan';

Дата, как и текст, должна быть оформлена в одинарные кавычки:

SELECT name, created_at FROM courses WHERE created_at > '2022-06-14';

--- Обработка особых значений ---

Как хранить в таблице информацию о незаполненных данных? Для этих целей существует специальное значение NULL.

Для сравнения и проверки на NULL необходимо использовать операторы IS и IS NOT, а не стандартные операторы сравнения.

SELECT * FROM users WHERE birthday IS NULL;
SELECT * FROM users WHERE birthday IS NOT NULL;

NULL и строка нулевой длины — это не одно и то же. В отличие от строки нулевой длины, NULL говорит, что никакое значение не занесено в текущую ячейку базы данных.
Еще одна интересная особенность — NULL не равен NULL. Так происходит, потому что нельзя сравнить одну пустоту с другой.

--- Фильтрация строк ---

В языке SQL существует возможность фильтрации строки по шаблону - подстроке, которую мы хотим найти. 
Для фильтрации текста по шаблону используется оператор LIKE, после которого мы указываем шаблон.

SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%';

В приведенном шаблоне символ % заменяет любое количество любых символов. В том числе и ноль символов.

Символ % можно поставить и в начало шаблона:

SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE '%man';

Символ % можно также использовать и в середине шаблона оператора LIKE:

SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name LIKE 'Sch%t';

Этот запрос выберет пользователей с фамилиями, которые начинаются на «Sch» и заканчиваются на «t» — например Schmitt.

Чтобы не задумываться о регистре букв в шаблоне можно воспользоваться оператором ILIKE, который ищет строки без учета регистра:

SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name ILIKE 'sch%t';

Можно вывести строки, на заданный шаблон совсем не похожие. Это делается с помощью оператора NOT LIKE:

SELECT id, first_name, last_name, email, birthday FROM users WHERE last_name NOT LIKE '%man';

Такой запрос вернет пользователей, чьи фамилии имеют любые окончания кроме "man".

--- Регулярные выражения ---

Язык SQL поддерживает работу с регулярными выражениями (regular expressions или RegEx). 
Это специальный язык, позволяющий достаточно точно определить шаблоны поиска в строке.

Для работы с регулярными выражениями используется оператор SIMILAR TO вместо LIKE.

SELECT * FROM users WHERE first_name SIMILAR TO '[AB]%';
SELECT * FROM users WHERE first_name SIMILAR TO '%[a-z]';
SELECT * FROM users WHERE first_name SIMILAR TO ''%[а-я]%';
SELECT * FROM users WHERE first_name SIMILAR TO '%[0-9]';
SELECT * FROM users WHERE first_name SIMILAR TO '%@%.%';
SELECT * FROM users WHERE first_name SIMILAR TO '%@%.__';
SELECT * FROM users WHERE first_name SIMILAR TO '%.___';
SELECT * FROM users WHERE first_name NOT SIMILAR TO '%@%.%';

Cамые полезные и часто используемые спецсимволы:
- Символ % соответствует любому количеству любых символов
- Квадратные скобки [] используются для перечисления конкретных символов — например, [АЕИОУЭЮ]
- Дефис - в квадратных скобках означает перечисление символов — например, [0-9] соответствует любой цифре
- Подчеркивание _ означает ровно один любой символ (букву или цифру)

--- Сложные условия фильтрации ---

Оператора OR. Он переводится как «ИЛИ» и указывает, что выражение будет верным, если хотя бы одно условие выполняется.
Оператор AND. Он переводится как «И» и указывает, что выражение будет верным, только если оба условия выполняются.

-- Как объединять условия --

SELECT *
FROM courses
WHERE body LIKE '%dolor%'
    AND created_at < '2022-06-14';

В этом запросе мы выбираем по двум условиям:
- В описании встречается слово dolor
- И при этом дата создания курса строго раньше 14 июня 2022 года

SELECT *
FROM users
WHERE id > 90 OR id IS NULL;

Логические операторы OR и AND можно комбинировать, однако нужно помнить об особенности — приоритет AND выше, чем OR.
Чтобы не создавать неоднозначностей, в сложных условиях рекомендуем использовать круглые скобки. 

SELECT *
FROM users
WHERE first_name = 'Andy'
    OR (created_at > '2022-06-13' AND created_at < '2022-06-14');

--- Фильтрация данных по диапазону ---

Оператор BETWEEN — это сокращенная версия двух условий, соединенных через AND. 

SELECT *
FROM users
WHERE birthday >= '2022-01-01' AND birthday <= '2022-02-01';

Теперь запишем диапазон дат через BETWEEN:

SELECT *
FROM users
WHERE birthday BETWEEN '2022-01-01' AND '2022-02-01';

SELECT *
FROM users
WHERE birthday NOT BETWEEN '2022-01-01' AND '2022-02-01';

Обычно оператор BETWEEN используют для дат, но его можно применять и с числами:

SELECT
  id,
  first_name,
  last_name,
  email
FROM users
WHERE id BETWEEN 15 AND 23;

Важно помнить, что BETWEEN включает в условие крайние значения из указанного диапазона.

--- Поиск строк по значениям из набора ---

Если понадобится десяток совпадений, можно использовать оператор IN. 
После него в скобках через запятую нужно указать значения, которым должно быть равно поле в запросе:

SELECT
    id,
    first_name,
    last_name
FROM users
WHERE id IN (1, 2, 5);

Если нужно исключить определенные записи, достаточно добавить NOT перед IN:

SELECT id, first_name, last_name
FROM users
WHERE id NOT IN (1, 2, 5);

Оператор IN можно использовать и с другими типами данных — например, со строками:

SELECT id, first_name, last_name
FROM users
WHERE first_name IN ('Lionel', 'Lucienne', 'Jennyfer');

--- Сортировка данных ---

 По умолчанию база возвращает данные в том порядке, в котором ей удобнее. Иногда этот порядок может совпасть с желаемым, но рассчитывать на это нельзя.

Сортировка задается с помощью оператора ORDER BY. За ней следует имя поля, по которому происходит сортировка:

SELECT
    id,
    username,
    created_at
FROM users ORDER BY username;

-- Прямой порядок сортировки --

Если порядок не указан, то сортировка происходит по возрастанию ASC. ( лексикографический порядок, то есть по алфавиту. )

ORDER BY created_at ASC;

-- Обратный порядок сортировки --

Чтобы выполнить сортировку в обратном порядке, указываем DESC:

ORDER BY created_at DESC;

-- Сортировка по нескольким полям --

ORDER BY first_name ASC, created_at DESC;

В этой выборке сначала выполняется сортировка по имени в прямом порядке. Затем внутри групп с одинаковым именем данные сортируются по created_at в обратном порядке.

-- Как сортировать NULL-значения --

В языке SQL нет единого стандарта как сортировать данные с NULL, и каждый провайдер, авторы базы данных, решает сам. Поэтому положение NULL-значений может отличаться в разных БД. Например, в MySQL NULL будут впереди при сортировке по возрастанию, тогда как в PostgreSQL в самом конце.

Потому, если ваши данные содержат NULL, то важно явно указывать, где должны располагаться значения NULL в результирующем наборе данных. Для этого можно пользоваться двумя расширениями:

NULLS FIRST
NULLS LAST

ORDER BY created_at ASC NULLS FIRST;
ORDER BY created_at DESC NULLS LAST;

--- Ограничение выборки ---

Чтобы ограничить выборку, используется LIMIT

SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10;

Чтобы реализовать пагинацию, одного LIMIT недостаточно. Еще понадобится смещение OFFSET:

SELECT
    id,
    username,
    email
FROM users ORDER BY id LIMIT 10 OFFSET 10;

Этот запрос:
- Отсортирует все записи.
- Пропустит первые 10 записей за счет части OFFSET 10.
- Возьмет следующие 10 записей.

--- Уникальные строки ---

В языке SQL существует специальный оператор DISTINCT, который удаляет повторяющиеся строки запроса и оставляет только уникальные.

SELECT DISTINCT course_id FROM course_members ORDER BY course_id;

Если мы добавим в наш запрос еще одно поле user_id, то это изменит результат запроса. В эту выборку попадут строки с уникальным сочетанием курса и слушателя.

SELECT DISTINCT
    course_id,
    user_id
FROM course_members ORDER BY course_id;

Есть модификация этого оператора — DISTINCT ON. Такой вариант оператора позволяет указать:

- Поле, которое должно быть уникальным.
- Поля, которые нужно вывести.

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at;

После DISTINCT ON в круглых скобках мы указываем поле, по которому будет проверяться уникальность. Далее мы перечисляем те поля, которые мы хотим видеть в запросе.
В DISTINCT ON можно указывать несколько полей.

При работе с DISTINCT ON важно правильно использовать сортировку. Первыми полями в ORDER BY должны быть те, которые идут после DISTINCT ON.

SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at DESC;

--- Агрегатные функции ---

Язык SQL — не просто язык запросов, а мощный инструмент, похожий на язык программирования, хотя и очень специфичный. Как и в других языках, здесь есть функции. Такие функции называются агрегатными.

Чтобы вызвать агрегатную функцию, нужно написать ее имя и затем в круглых скобках передать аргументы — переменные, над которыми будут совершаться действия.

-- Функция COUNT --

Функцию COUNT — она возвращает количество записей в выборке.

SELECT COUNT(*) FROM users;

Этот запрос выведет нам ровно одно число — количество строк в запросе. 

Еще в качестве аргумента мы можем передать имя поля. В этом случае функция вернет нам количество строк, в которых поле НЕ равно NULL.

SELECT COUNT(id) FROM users;

-- Функция SUM --

Функция SUM возвращает сумму всех значений:

SELECT SUM(spent_minutes) FROM course_reviews;

В качестве аргумента в функцию SUM нужно передать числовое поле. Если передать поле, в котором хранятся строки или даты, то запрос вернет ошибку.

-- Функция AVG --

Чтобы найти среднее арифметическое всех значений, нужно воспользоваться функцией AVG (average — среднее).

Работает функция так же как и SUM. В качестве аргумента нужно передать числовое поле.

SELECT AVG(spent_minutes) FROM course_reviews WHERE user_id = 9;

-- Функции MAX и MIN --

Функции MAX и MIN позволяют найти максимальное и минимальное значение соответственно. 

SELECT MAX(spent_minutes) FROM course_reviews;
SELECT MIN(spent_minutes) FROM course_reviews;

В качестве аргументов в функции MAX и MIN можно передавать поля числовых типов, а так же даты и строки. 

--- Группировка по выборке ---

Группировка данных позволяет объединить одинаковые значения в заданных полях в группы, а затем выполнять подсчеты для каждой группы.

Для группировки данных существует специальный оператор GROUP BY

SELECT
    user_id,
    COUNT(*)
FROM course_members
GROUP BY user_id
ORDER BY user_id;

-- Псевдонимы для столбцов --

Чтобы присвоить столбцу псевдоним, нужно после его определения записать AS и указать желаемое имя.

SELECT
    user_id AS student,
    COUNT(*) AS courses_count
FROM course_members
GROUP BY user_id
ORDER BY user_id;

-- Как работает GROUP BY --

Важно помнить, что поля, которые вы будете выводить в запросе, нужно указывать в операторе GROUP BY или применять к ним агрегатную функцию.

SELECT
    user_id AS student,
    COUNT(user_id) AS courses_count,
    MAX(created_at) AS last_reg
FROM course_members
GROUP BY user_id
ORDER BY user_id;

--- Фильтрация c помощью оператора HAVING ---

Иногда встречаются задачи, в которых требуется отфильтровать записи после группировки.
В этой задаче понадобится дополнение к GROUP BY, которое называется HAVING. Именно его мы изучим в этом уроке.

С помощью ключевого слова HAVING мы можем задать условия на строки выборки после группировки данных.

SELECT
    user_id,
    SUM(spent_minutes)
FROM course_reviews
WHERE user_id <= 40
GROUP BY user_id
HAVING SUM(spent_minutes) < 30
ORDER BY user_id;

Условия в HAVING проверяются после группировки, поэтому они задаются после предложения GROUP BY. 
В этом и состоит отличие от условий WHERE, которые применяются к строкам исходной таблицы до группировки.


































































