--- Введение ---

Java — язык программирования общего назначения, который является одним из самых востребованных языков. Он используется для создания приложений в разных областях: в вебе, разработке игр, мобильного ПО, и даже программ для корпораций и научных институтов.

--- Первая программа ---

class App {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

-- Комментарии --

Комментарии в Java бывают трех видов:
- Однострочные комментарии начинаются с //
- Многострочные комментарии начинаются с /* и заканчиваются на */
- Документирующие комментарии начинаются с /** и заканчиваются на */

---  Инструкции (Statements) ---

Инструкция — это команда для компьютера. Код на Java — это набор инструкций, которые, обычно, отделяются друг от друга символом ;.
Инструкция — это единица исполнения. Программа, которая запускает код на Java, выполняет инструкции строго по очереди.


--- Арифметические операции ---

На базовом уровне компьютеры оперируют только числами. Даже в прикладных программах на высокоуровневых языках внутри много чисел и операций над ними.

+ - сложение
* — умножение
/ — деление
- — вычитание
% — остаток от деления

-- Операторы --

Знак операции, такой как +, называют оператором. Оператор — просто символ, который выполняет операцию, например, сложение.

Операции, которые требуют наличия двух операндов, называются бинарными.
Бывают еще:
Унарные — с одним операндом
Тернарные — с тремя операндами

-- Коммутативная операция --

Бинарная операция считается коммутативной, если вы получаете тот же самый результат, поменяв местами операнды.

-- Числа с плавающей точкой --

В математике существуют разные виды чисел, например:
Натуральные — это целые числа от 1 и больше
Рациональные — это числа с точкой, например, 0.5
С точки зрения устройства компьютеров, между этими видами чисел — пропасть.

Разработчикам важно понимать, что операции с плавающими числами неточны, но эту точность можно регулировать.

https://habr.com/ru/articles/112953/

--- Строки ---

Любой одиночный символ в кавычках — это строка. Пустая строка "" — это тоже строка. То есть строкой мы считаем все, что находится внутри кавычек, даже если это пробел, один символ или вообще отсутствие символов.

Для вывода кавычки " используется символ экранирования: \.
Он же применяется для вывода символа \ ( напр. \\ ).

-- Экранирующие последовательности --

Символ перевода строки: \n
\n — это пример экранирующей последовательности (escape sequence). Их еще называют управляющими конструкциями. Хотя таких символов не один десяток, в программировании часто встречаются всего несколько.

-- Конкатенация --

Операция соединения строк в программировании называется конкатенацией и выглядит так:

"Dragon" + "stone"

https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8#%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F

--- Переменные ---

Переменная представляет собой именованную ячейку памяти, которой может быть присвоено значение.

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить в начале. Имена переменных регистрозависимы, то есть имя hello и имя heLLo - это два разных имени и две переменные. 

var first = "Kings";

Java — статически типизированный язык. Это значит, что тип переменной задается при определении и больше не меняется.

-- Константы --

final var pi = 3.14;

В отличие от переменных, в начале определения константы используют ключевое слово final. Оно сообщает компилятору запрет на изменение. Любая попытка поменять константу приведет к ошибке.

--- Именование ---

Постарайтесь давать им такие имена, чтобы они были максимально понятны без контекста, без изучения окружающего кода.
Существует общепринятое правило: не используйте транслит для имен, только английский язык. 

В именовании переменных можно выделить четыре основных подхода, которые иногда комбинируют друг с другом. Все эти подходы проявляют себя, когда имя переменной состоит из нескольких слов:

kebab-case — составные части переменной разделяются дефисом (my-super-var)
snake_case — для разделения используется подчеркивание (my_super_var)
CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
lowerCamelCase — каждое слово в переменной пишется с заглавной буквы, кроме первого (mySuperVar)

В Java используется CamelCase и его вариация lowerCamelCase, при котором первая буква первого слова — строчная.

-- Магические числа --

Магические числа (magic numbers) — числа, происхождение которых невозможно понять без глубокого знания происходящего внутри участка кода.
Выход из ситуации прост: достаточно создать переменные с правильными именами.

https://ru.hexlet.io/blog/posts/naming-in-programming

--- Типы данных ---

Внутри высокоуровневых языков программирования данные разделяются по типам. Например, строки относятся к типу String, а числа — к типу int.

-- Явная типизация --

int x = 3;
String greeting = "Hello Hexlet!";

Java — это статически типизированный язык. В таких языках тип переменной фиксируется при ее объявлении. В большинстве языков для этого перед именем переменной указывается ее тип — в примере выше это число (int) и строка (String).

Раньше на Java создавали переменные только так, до тех пор пока не появился var. var – специальное ключевое слово, которое включает механизм вывода типов. Вывод типов автоматически определяет тип присваиваемого значения и связывает его с переменной.

Вывод типов предпочтителен в большинстве ситуаций, однако бывает такое, что выводимый тип нас не устраивает. Тогда мы можем указать тип явно.

-- Какие бывают типы --

Глобально, типы данных в Java делятся на две большие группы:
Примитивные — предопределены в Java
Ссылочные или не примитивные — создаются самим программистом, за исключением String и Array

Всего в Java восемь примитивных типов данных:
byte
short
int
long
float
double
boolean
char

Рассмотрим первые четыре типа. Это целые числа разного размера:
byte — занимает в памяти 1 байт, значит может хранить числа от -128 до 127
short — занимает в памяти 2 байта
int — занимает в памяти 4 байта
long — занимает в памяти 8 байт

-- Значение null --

// Определение переменной без инициализации значением
// С var такое не сработает, так как невозможно вывести тип
String a;

Что находится внутри переменной a? Если мы ее распечатаем, то увидим null. Значение null используется для ссылочных типов, когда значение не определено.

Любой ссылочный тип данных может принимать значение null.А вот примитивные типы и null не совместимы. Примитивное значение всегда должно быть определено.

-- Значение по умолчанию --

В Java компилятор не присваивает автоматически дефолтные значения локальным переменным примитивных типов, поэтому разработчик должен явно инициализировать переменную перед её использованием.

Если попытаться обратиться к локальной переменной до её инициализации, компилятор выдаст ошибку.

-- Явное преобразование типов --

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой. Простейший пример – работа с формами на сайтах.

Данные формы всегда приходят в текстовом виде, даже если значение число. Вот как его можно преобразовать:

var number = Integer.parseInt("345");

Если нужно конвертировать из примитивного типа в примитивный, то все проще. Достаточно перед значением в скобках указать желаемый тип. В результате значение справа преобразуется в значение другого типа, указанного слева:

var result = (int) 5.1;

-- Неявное преобразование типов --

Некоторые преобразования в Java могут выполняться автоматически без явного указания программистом. Такое преобразование называется неявным преобразованием типов. Если в одном выражении участвуют разные типы данных, Java может сама без явного указания преобразовать один тип данных в другой для выполнения операции. Для этого нужно, чтобы типы были совместимы между собой и чтобы размерность преобразуемого была равна или меньше результирующего типа.

Например, числовые типы данных совместимы друг с другом, но автоматическое преобразование из числового типа в boolean не сможет выполниться.

Также без проблем и без потери точности автоматически выполнится преобразование из типа short в тип int. В этом случае значение типа short, которое занимает в памяти 2 байта, расширяется до типа int, которое занимает 4 байта.А вот обратное преобразование не будет выполнено автоматически.

Еще одним примером неявного преобразования типов является преобразование чисел в строку при конкатенации числа со строкой. В этом случае Java автоматически преобразует число в строковое представление и объединяет его с другой строкой.

---  Вызов методов ---

Функции — одна из ключевых конструкций в программировании, без них невозможно сделать практически ничего. Функции бывают как встроенные в язык, так и добавленные программистом.
В Java невозможно создать обычную функцию, как это позволяет делать большинство других языков. Все функции Java создаются только внутри классов, которые мы пока не разбирали. А функции, которые определены внутри классов, принято называть методами.

Методы — это действия, которые нужно выполнить над данными, к которым они применяются.
Основное в работе с методами – понять принцип возврата значения. 

-- Параметры методов --

Параметров может быть больше, чем один.
Параметры могут содержать значение по умолчанию там, где это значение используется чаще всего.

--- Ошибки оформления, синтаксиса и линтера ---

-- Синтаксические ошибки --

Примером может быть забытая ;, неправильно расставленные скобки и другие детали. Подобные ошибки называются синтаксическими, потому что они нарушают правила синтаксиса языка. Эти ошибки обнаруживаются на этапе компиляции, до реального запуска.

-- Ошибки типов --

Типы в языках программирования определяют операции которые можно выполнять над данными.
Java это статически типизированный язык, поэтому процесс проверки соответствия типов выполняется на этапе компиляции до запуска программы на выполнение.

-- Ошибки выполнения --

Ошибки, которые возникают в процессе работы. Их тяжело или даже невозможно отследить на этапе компиляции. Например, в Java деление на ноль является ошибкой, но возникает она уже во время выполнения программы.
Другой пример, когда возникают эти ошибки это работа с файлами. Попытка прочитать несуществующий файл или создать файл, который уже был создан, приведут к ошибке выполнения.

Ошибки выполнения базируются на механизме называемом исключения. Когда происходит подобная ошибка, говорят что было выброшено исключение (или возбуждено исключение, или возникло исключение). Исключения имеют имена и их видно в выводе ошибки. В случае деления на ноль это java.lang.ArithmeticException. Особенностью системы исключений является то, что исключениями можно управлять.

-- Логические ошибки --

Самые сложные ошибки, которые не приводят к остановке программы. То есть программа работает, но ее результат не соответствует ожидаемому.
Так как эти ошибки не отлавливаются автоматически, профессиональные программисты пишут автоматизированные тесты, которые проверяют, что программа работает правильно.

-- Ошибки линтера --

Код программы следует оформлять определенным образом, чтобы он был достаточно понятным и простым в поддержке.
Специальные наборы правил — стандарты — описывают различные аспекты написания кода. Конкретно в Java самым распространенным стандартом является стандарт от Sun.
В любом языке программирования существуют утилиты — так называемые линтеры. Они проверяют код на соответствие стандартам. В Java это checkstyle.
Соблюдение данных правил не влияет на результат, но помогает писать код понятнее и проще для восприятия.

--- Вызов метода — выражение, неизменяемость строк ---

В программировании выражение — нечто возвращающее результат, который можно использовать.
Особенность выражений в том, что они возвращают результат, который можно использовать — например, присвоить переменной или вывести на экран.
Но не все в программировании является выражением. Определение переменной — это инструкция, она не может быть частью выражения.
Поговорим о методах. Вызов метода — это выражение или нет? Мы знаем, что методы возвращают результат, то есть да, они выражения. 

-- Неизменяемость строк --

Дело в том, что строки в Java неизменяемы. Не существует способа и методов, способных изменить саму строку. Любой метод строки может только вернуть новую строку.

---  Цепочки вызовов методов ---

var name = " How much is the fish?   ";
name = name.trim().replace("?", "").replace(" ", "-").toLowerCase();

Благодаря тому, что каждый метод возвращает новую строку, мы можем продолжать обрабатывать ее, вызывая методы подряд. Если цепочка методов становится слишком длинной, то ее можно разбить на несколько строк:

name = name.trim()
    .replace("?", "")
    .replace(" ", "-")
    .toLowerCase();

--- Детерминированность ---

Метод называется детерминированным тогда, когда для одних и тех же входных параметров он возвращает один и тот же результат. 

-- Побочные эффекты --

Вывод на экран и возврат значения из метода — разные и независимые операции.
Побочным эффектом называют действия, которые соприкасаются с внешним окружением. К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран, печать на принтере и так далее.
Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании и ненадежен. При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

--- Стандартная библиотека ---

Java, как и любой другой язык, поставляется с набором полезных методов. Все вместе они составляют так называемую стандартную библиотеку. В нее обычно входят тысячи методов, которые невозможно выучить — этого и не нужно делать. Подразумевается, что любой программист знает, где искать документацию по ним и примерно представляет себе, чего он хочет достичь. 

Вот некоторые советы, как узнавать о новых методах:
- Всегда четко отслеживайте, с каким типом данных вы сейчас работаете. Почти всегда вы найдете необходимый метод в соответствующем разделе документации — например, для работы со строками нужно изучать строковые методы
- Периодически открывайте раздел со стандартными методами по изучаемой тематике и просто пробегайтесь по ним, изучая сигнатуры и способы использования
- Чаще читайте чужой код, особенно код библиотек, которые вы используете. Он весь доступен на GitHub

--- Какие бывают методы ---

-- Вызовы методов у объектов --

var random = new Random();
random.nextInt(10);

Такие методы выполняют действия над объектами, у которых они вызываются, и часто не принимают никаких аргументов.

-- Вызовы статических методов --

Math.random();

Класс Math в данном случае нужен только для вызова, потому что методы определены внутри них. Java не позволяет определять методы вне классов.

Выводы
- Статические методы не связаны с конкретными объектами и вызываются из класса напрямую
- Нестатические методы строят свою логику относительно данных самого объекта и вызываются у конкретных объектов

--- Определение методов ---

Определение собственных методов значительно упрощает написание и поддержку программ. Например, методы позволяют объединять составные операции в одну.

-- Как создавать методы --

       public           static                void                myMethod    (var first, var second)

модификатор доступа | тип метода | тип возвразаемого значения |  имя метода  |      параметры

--- Метод main ---

В таком виде метод main, как мы его определяем, имеет особенное значение для Java. 
Java автоматически его вызывает, когда программа запускается из консоли.
Обязательно ли его определять? Нет, Java не накладывает никакого ограничения на то, какие и сколько методов вы определите в классе. Так же как и нет ограничения на количество и имена классов.

--- Возврат значений ---

class App {
    public static String greeting() {
        return "Winter is coming!";
    }
}

Здесь String - тип возвращаемого значения. 
А return – это особая инструкция. Она берет выражение справа и отдает его наружу тому коду, который вызвал метод. Как только Java натыкается на return, выполнение метода на этом завершается.

---  Параметры методов ---

Методы могут не только возвращать значения, но и принимать их в виде параметров.

System.out.println("я параметр");

Параметры в Java всегда обязательны. Если методу нужны параметры, а мы попробуем написать код без параметра, то компилятор выдаст ошибку.

--- Необязательные параметры методов ---

В отличие от других языков, в Java нет возможности задать значение по умолчанию, но ее можно имитировать с помощью перегрузки методов.
Что это такое? Java позволяет создать несколько методов с одинаковым именем. У таких одинаковых методов должно выполняться одно из условий:
- Разные типы входных параметров
- Разное количество параметров
- Все перечисленное выше одновременно

Во время компиляции выбирается та версия метода, которая совпадает по типу и количеству параметров. Если такой метод не был найден, то возникнет ошибка.

Перегрузка методов может приводить к дублированию кода, особенно когда речь идет про значения по умолчанию. В таких ситуациях логика одинаковая, разница лишь в начальной инициализации.
Для снижения дублирования достаточно сделать два шага:
- Сначала определить общий метод, который принимает больше всего параметров
- Затем вызывать его из тех методов, где есть значения по умолчанию

class App {
    public static int sum(int x, int y) {
        return x + y;
    }

    public static int sum(int x) {
        // Вызываем уже готовый метод суммирования
        return sum(x, 10);
    }
}

--- Логические операции ---

-- Операции сравнения --

Список операций сравнения в Java:

<  — меньше
<= — меньше или равно
>  — больше
>= — больше или равно
== — равно
!= — не равно

Результат вычисления этих выражений — это одно из двух специальных значений:
true — «истина»
false— «ложь»

Это новый для нас тип данных — boolean.
Метод, возвращающий boolean, называется предикатом.

-- Сравнение строк --

// Какой результат будет в этих примерах — `true` или `false`?

"a" == "a";
"a".toUpperCase() == "a".toUpperCase();

Правильный ответ: в первом случае true, во втором — false.

-- Сравнение по ссылке и по значению --

Из-за этих технических особенностей на сравнение данных между собой можно смотреть двумя способами:

- То же самое — тот же участок памяти
- Такое же — одинаковые значения независимо от того, куда указывают адреса

Как и во многих других языках, в Java все данные делятся на два больших типа:

- Примитивные данные сравниваются по значению, независимо от адресов
- Ссылочные данные сравниваются по адресам

-- Особенности строк --

Строки относятся к ссылочным типам данных, но ведут себя странно:

// Сравнение, как у примитивных типов данных
"hm" == "hm"; // true

// Сравнение, как у ссылочных типов данных
"hexlet".toUpperCase() == "hexlet".toUpperCase(); // false

Когда Java встречает явно создаваемую строку, происходит проверка на существование уже в памяти такой строки.
Если есть, то она переиспользуется, если нет — создается.

Но если строка возвращается из метода, то она помещается в свою область памяти со своим уникальным адресом:

// Выделяется новая память в любом случае
var name1 = "java".toUpperCase(); // "JAVA"

// Выделяется новая память в любом случае
var name2 = "java".toUpperCase(); // "JAVA"
name1 == name2; // false

В прикладном программировании мы чаще сравниваем строки по значению, чем по ссылке. Для этого в строки встроен метод equals():

var name1 = "java".toUpperCase(); // "JAVA"
var name2 = "java".toUpperCase(); // "JAVA"
name1.equals(name2); // true

Помимо equals(), в строки встроен метод equalsIgnoreCase(), который выполняет проверку по значению без учета регистра.

Иногда сравнение строк в Java ведет себя как сравнение значений, но никогда не делайте ставку на это. При изменении кода легко забыть поправить проверку и получить ошибку. Всегда используйте методы, когда нужно сравнивать по значению.

-- Комбинирование операций и методов --

Логические операции — это выражения. Значит, логические операции можно комбинировать с другими выражениями.
Приоритет арифметических операций выше логических. Значит, сначала вычисляется арифметическое выражение, затем результат участвует в логическом сравнении.

--- Логические операторы ---

Оператор  И  &&
Оператор ИЛИ ||
Отрицание     !

Оператор && означает «И». В этом случае выражение считается истинным, только если истинен каждый операнд — каждое из составных выражений. Другими словами, && означает «и то, и другое».
Кроме && часто используется оператор || — «ИЛИ». Он означает «или то, или другое, или оба».
Наряду с конъюнкцией (И) и дизъюнкцией (ИЛИ), часто используется операция «отрицание». Отрицание меняет логическое значение на противоположное. 

Область математики, в которой изучаются логические операторы, называется булевой алгеброй.

--- Условные конструкции ---

Условные конструкции позволяют выполнять разный код, основываясь на логических проверках.

-- Конструкция if --

if — конструкция языка, управляющая порядком инструкций. В скобках ей передается логическое выражение, а затем описывается блок кода в фигурных скобках. Этот блок кода будет выполнен, только если условие выполняется.

Все константы или переменные, определенные внутри блока кода, будут видны только внутри этого блока.

-- Конструкция if-else --

if (x > 5) {
    // Если условие true
} else {
    // Если условие false
}

-- Конструкция else if --

В самой полной версии конструкция if содержит не только ветку else, но и другие условные проверки с помощью else if. Такой вариант используется при большом количестве проверок, которые взаимоисключают друг друга:

if (/* что-то */) {

} else if (/* другая проверка */) {

} else if (/* другая проверка */) {

} else {

}

Здесь стоит обратить внимание на два момента:
- Ветка else может отсутствовать
- Количество else if условий может быть любым

-- Тернарный оператор --

В Java существует конструкция, которая по своему действию аналогична конструкции if-else, но при этом является выражением. Она называется тернарный оператор.
Тернарный оператор — единственный в своем роде оператор, требующий три операнда. Он помогает писать меньше кода для простых условных выражений. 

Общий шаблон выглядит так:
<predicate> ? <expression on true> : <expression on false>

То есть сначала мы записываем логическое выражение, а дальше два разных варианта поведения:
- Если условие истинно, выполняет вариант до двоеточия
- Если условие ложно, выполняет вариант после двоеточия

--- Конструкция Switch ---

Конструкция switch — это специализированная версия if, созданная для некоторых особых ситуаций.

switch (status) {
    case "processing":
        // Делаем раз
        break;
    case "paid":
        // Делаем два
        break;
    case "new":
        // Делаем три
        break;
    default: // else
        // Делаем четыре
}

С точки зрения количества элементов, switch — довольно сложная конструкция. В нее входят:

- Внешнее описание с ключевым словом switch. В нем два элемента:
Переменная, по значениям которой switch будет выбирать поведение
Фигурные скобки для вариантов выбора
- Конструкции case и default, внутри которых описывается поведение для разных значений рассматриваемой переменной. Каждый case соответствует if, как в примере выше. Здесь default — это особая ситуация, соответствующая ветке else в условных конструкциях. Как и в случае с else, указывать default необязательно
- Конструкция break, который предотвращает «проваливание». Если ее не указать, то после выполнения нужного case, выполнение перейдет к следующему case. Этот цикл будет повторяться до ближайшего break или до конца switch.

Фигурные скобки в switch не определяют блок кода, как это было в других местах. Внутри допускается только тот синтаксис, который показан выше — там можно использовать case или default. А вот внутри каждого case (и default) ситуация другая. Здесь можно выполнять любой произвольный код.

Switch хоть и встречается в коде, но технически всегда можно обойтись без него.
Польза этой конструкции в том, что она лучше выражает намерение программиста, когда нужно проверять конкретные значения переменной. В отличие от блоков else if, код со switch становится немного длиннее, но читать его гораздо проще.

--- Цикл while ---

Алгоритм — это последовательность действий или инструкций, которая приводит нас к какому-то ожидаемому результату.

Для выполнения повторяющихся действий как раз и нужны циклы. Каждый такой повтор называется итерацией.

var i = 1;

while (i <= lastNumber) {
    System.out.println(i);
    i = i + 1;
}

Конструкция читается так: «делать то, что указано в теле цикла, пока истинно условие i <= lastNumber»

В коде использован цикл while. Он состоит из трех элементов:
- Ключевое слово while. Несмотря на схожесть с вызовом методов, это не вызов метода
- Предикат — условие, которое указывается в скобках после while и вычисляется на каждой итерации
- Тело цикла — блок кода в фигурных скобках, аналогичный блоку кода в методе. Все константы или переменные, определенные внутри этого блока, будут видны только внутри этого блока

Самое главное в цикле — завершение его работы, то есть выход из цикла. Процесс, который порождает цикл, должен в конце концов остановиться. Ответственность за остановку полностью лежит на программисте.
Когда все же нужны циклы, а когда можно обойтись без них? Невозможно обойтись без циклов тогда, когда алгоритм решения задачи требует повторения каких-то действий, при этом количество этих операций заранее неизвестно.

-- Синтаксический сахар --

Подобные конструкции index = index + 1 в Java используются довольно часто, поэтому создатели языка добавили сокращенный вариант записи: index += 1. Такие сокращения принято называть синтаксическим сахаром, потому что они делают процесс написания кода немного проще и приятнее.

Существуют сокращенные формы для всех арифметических операций и для конкатенации строк:

a = a + 1 → a += 1
a = a - 1 → a -= 1
a = a * 2 → a *= 2
a = a / 1 → a /= 1
a = a + "foo" → a += "foo"

--- Использование циклов ---

В программировании есть отдельный класс задач, который не может обойтись без циклов — он называется агрегированием данных.

К таким задачам относится поиск:
- Максимального значения
- Минимального значения
- Суммы
- Среднего арифметического

В математике существует понятие нейтральный элемент операции. Операция с таким элементом не изменяет то значение, над которым проводится операция:
- В сложении любое число плюс ноль дает само число
- При вычитании – то же самое
- Даже у конкатенации есть нейтральный элемент – это пустая строка: "" + "one" будет "one"

-- Агрегация данных (Строки) --

При агрегации строка формируется динамически, то есть заранее неизвестно, какого она размера и что будет содержать. 

-- Обход строк --

Циклы подходят не только для обработки чисел, но и при работе со строками. В первую очередь благодаря возможности получить конкретный символ по его индексу. 

-- Формирование строк в циклах --

Еще одно использование циклов — формирование строк. Подобная задача нередко встречается в программировании. Она сводится к обычной агрегации через конкатенацию.

--- Условия внутри цикла и возврат значений ---

Тело цикла, как и тело метода — это место выполнения инструкций. Значит, мы можем использовать внутри него все изученное ранее — в том числе условные конструкции.

-- Возврат из циклов --

Работа с циклами обычно сводится к двум сценариям:
- Агрегация — накопление результата во время итераций и работа с ним после цикла. Переворот строки как раз относится к такому варианту
- Выполнение цикла до достижения необходимого результата и выход. Например, задача поиска простых чисел.

--- Цикл for ---

Цикл while идеален для ситуаций, когда количество итераций неизвестно заранее, например, при поиске простого числа.

Когда количество итераций известно, предпочтительнее использовать цикл for.

for (var i = 0; i < str.length(); i++) {
    result = str.charAt(i) + result;
}

Цикл с индексом i повторяется, пока i < str.length(), а также после каждого шага увеличивает i на 1.

В определении цикла for есть:
- Начальное значение счетчика. Этот код выполняется ровно один раз перед первой итерацией
- Предикат — условие повторения циклов. Выполняется на каждой итерации. Точно так же как и в while
- Описание изменения счетчика. Этот код выполняется в конце каждой итерации

-- Инкремент и декремент --

Из языка Си в Java перекочевали две операции: инкремент ++ и декремент --, которые очень часто встречаются вместе с циклами.

Эти унарные операции увеличивают и уменьшают на единицу число, записанное в переменную:

i++
i--
++i
--i

При использовании префиксной нотации сначала происходит изменение переменной, а потом возврат. При использовании постфиксной нотации — наоборот: можно считать, что сначала происходит возврат, а потом изменение переменной.

Рекомендации по использованию:
- Никогда не смешивайте операции без побочных эффектов с операциями с побочными эффектами. То же самое касается и методов
- Используйте инкремент и декремент только там, где нет разницы между префиксным и постфиксным вариантом — отдельно от всего, на отдельной строчке кода

--- Пакеты ---

Если два класса с одинаковыми именами оказываются в одном проекте, программа не будет компилироваться. Переименовать свой класс можно, но с классами из библиотек так просто не получится. Требование уникальности имен классов делает использование кода, написанного другими людьми, затруднительным, поскольку это постоянно будет приводить к конфликтам имен.

Для решения этой проблемы в Java используются пакеты. Пакеты представляют собой механизм для организации классов в логически связанные группы. Они похожи на папки в файловой системе, которые используются для организации файлов. Пакеты позволяют избежать конфликтов имен классов, так как разные пакеты могут иметь классы с одинаковыми именами.

-- Определение пакетов --

Для определения пакета используется ключевое слово package в самом начале файла с кодом, после которого следует имя пакета. Структура пакетов тесно связана с файловой структурой. Имя пакета всегда соответствует директории проекта, в которых находятся файлы с исходным кодом.

// Файл company/User.java
package company;

public class User {
    // тут код для работы с пользователем
}

Пакеты могут быть вложенными, то есть один пакет может содержать в себе другие пакеты. Если пакет вложенный, то и директория тоже вложенная. Например, если классы размещены в пакете io.hexlet.model, то и соответствующие java файлы в проекте должны быть расположены в директории io/hexlet/model.

// Файл io/hexlet/model/User.java
package io.hexlet.model;

-- Использование пакетов --

Классы из одного пакета могут обращаться друг к другу просто по имени. Компилятор поймет, что мы хотим использовать класс User, расположенный в том же пакете.

Но в разработке постоянно приходится использовать классы и из других пакетов. Чтобы в своем коде использовать классы из другого пакета, их нужно импортировать. Для импорта класса используется ключевое слово import, после которого идет полное имя класса, который мы хотим импортировать:

package io.hexlet;

import io.hexlet.model.User;

class App {
    public static void main(String[] args) {
        var greeting = User.getGreeting("John");
        System.out.println(greeting);
    }
}

Импортирование позволяет в коде обращаться к классу просто по его имени, иначе пришлось бы писать полное имя, включая название пакета (fully qualified), что может быть не удобно:

var greeting = io.hexlet.model.User.getGreeting("John");

Как мы уже обсудили выше, пакеты решают проблему конфликта имен, так как разные пакеты могут содержать классы с одинаковым именем. Но что делать, если в одном месте нужны два класса из разных пакетов с одинаковым именем? В таком случае можно использовать полное имя класса:

package io.hexlet;

class App {
    public static void main(String[] args) {
        var name = io.hexlet.utils.User.getUserName();
        var greeting = io.hexlet.model.User.getGreeting(name);
        System.out.println(greeting);
    }
}

Чтобы немного упростить код, можно импортировать один из классов. Мы импортируем тот, который используем чаще всего. А для наименее используемого будем писать полное имя класса.

Существует еще один способ импорта. Вы можете импортировать все классы из пакета при помощи *

import java.util.*

Такой способ импортирует весь пакет целиком, то есть в коде мы можем обратиться к любому классу пакета напрямую по имени. Этот способ на первый взгляд может показаться удобным, так как не требуется импортировать каждый класс по отдельности при необходимости использования нескольких классов из одного пакета. Однако, c таким способом нужно быть осторожным, так как он захламляет пространство имен, и классы из разных пакетов могут пересечься по именам.

-- Статический импорт --

Java позволяет импортировать и использовать статические методы без явного указания класса. Особенно полезна эта возможность, когда часто приходится использовать какие-то методы. Это делает код более читаемым и компактным, так как не нужно каждый раз указывать имя класса при вызове статического метода:

import static java.lang.Math.*;

public class Main {
    public static void main(String[] args) {
        // Можем опустить указание класса при вызове метода
        double result = sqrt(16);
        System.out.println(result);
    }
}